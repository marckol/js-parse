/* 
 * The MIT License
 *
 * Copyright 2021 Marc KAMGA Olivier <kamga_marco@yahoo.com;mkamga.olivier@gmail.com>.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

//require_once('serenix_parser_statements.js');

//require_once('xregexp-all.js');


if (!window.hasOwnProp) {
    /**
     * 
     * @param {Object} o  The object
     * @param {String} n  Property name
     * @returns {Boolean}
     */
    window.hasOwnProp = function (o, n) {
        return Object.prototype.hasOwnProperty.call(o, n);
    };
}

var LINE_SEPARATOR_CODE = 0x2028;



var PARAGRAPH_SEPARATOR_CODE = 0x2029;

var PARAGRAPH_SEPARATOR = '\u2029';

var LINE_SEPARATOR = '\u2028';


var LS = LINE_SEPARATOR;

var PS = PARAGRAPH_SEPARATOR;

var LF = "\n";

var CR = "\r";

var LINE_TERMINATORS = [LF, LS, PS, CR + LF, CR];

var LINE_TERMINATOR_RE = new XRegExp("\\n|\\u2028|\\u2029|\\r\\n|\\r");

var LINE_TERMINATOR_GLOBAL_RE = new XRegExp("\\n|\\u2028|\\u2029|\\r\\n|\\r", "g");
var VARIABLE_ID_RE = "(?:[\\$A-Z_a-z\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B4\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309B-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AD\\uA7B0-\\uA7B7\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF30-\\uDF4A\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2]|\\uD804[\\uDC03-\\uDC37\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF50\\uDF5D-\\uDF61]|\\uD805[\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDDD8-\\uDDDB\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA\\uDF00-\\uDF19]|\\uD806[\\uDCA0-\\uDCDF\\uDCFF\\uDEC0-\\uDEF8]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50\\uDF93-\\uDF9F]|\\uD82C[\\uDC00\\uDC01]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB]|\\uD83A[\\uDC00-\\uDCC4]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1]|\\uD87E[\\uDC00-\\uDE1D])(?:[\\$0-9A-Z_a-z\\xAA\\xB5\\xB7\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B4\\u08E3-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0AF9\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58-\\u0C5A\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D5F-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1369-\\u1371\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19DA\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AD\\uA7B0-\\uA7B7\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA8FD\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDDFD\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE0\\uDF00-\\uDF1F\\uDF30-\\uDF4A\\uDF50-\\uDF7A\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE38-\\uDE3A\\uDE3F\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE6\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2]|\\uD804[\\uDC00-\\uDC46\\uDC66-\\uDC6F\\uDC7F-\\uDCBA\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD00-\\uDD34\\uDD36-\\uDD3F\\uDD50-\\uDD73\\uDD76\\uDD80-\\uDDC4\\uDDCA-\\uDDCC\\uDDD0-\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE37\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEEA\\uDEF0-\\uDEF9\\uDF00-\\uDF03\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3C-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF50\\uDF57\\uDF5D-\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC80-\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDB5\\uDDB8-\\uDDC0\\uDDD8-\\uDDDD\\uDE00-\\uDE40\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEB7\\uDEC0-\\uDEC9\\uDF00-\\uDF19\\uDF1D-\\uDF2B\\uDF30-\\uDF39]|\\uD806[\\uDCA0-\\uDCE9\\uDCFF\\uDEC0-\\uDEF8]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDED0-\\uDEED\\uDEF0-\\uDEF4\\uDF00-\\uDF36\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50-\\uDF7E\\uDF8F-\\uDF9F]|\\uD82C[\\uDC00\\uDC01]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99\\uDC9D\\uDC9E]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD83A[\\uDC00-\\uDCC4\\uDCD0-\\uDCD6]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1]|\\uD87E[\\uDC00-\\uDE1D]|\\uDB40[\\uDD00-\\uDDEF])*";

// only the symbols that aren’t already matched by `identifierStart`
// According to ES6 + Unicode 8.0.0
var REGEX_IDENTIFIER = /^(?:[\$A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D])(?:[\$0-9A-Z_a-z\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF])*$/,
    // According to ES6 + Unicode 5.1.0
    REGEX_IDENTIFIER_UNICODE5 = /^(?:[\$A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0523\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0621-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971\u0972\u097B-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D28\u0D2A-\u0D39\u0D3D\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC\u0EDD\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8B\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10D0-\u10FA\u10FC\u1100-\u1159\u115F-\u11A2\u11A8-\u11F9\u1200-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u1676\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19A9\u19C1-\u19C7\u1A00-\u1A16\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u2094\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2C6F\u2C71-\u2C7D\u2C80-\u2CE4\u2D00-\u2D25\u2D30-\u2D65\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31B7\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FC3\uA000-\uA48C\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA65F\uA662-\uA66E\uA67F-\uA697\uA717-\uA71F\uA722-\uA788\uA78B\uA78C\uA7FB-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA90A-\uA925\uA930-\uA946\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAC00-\uD7A3\uF900-\uFA2D\uFA30-\uFA6A\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1E\uDF30-\uDF4A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F\uDD00-\uDD15\uDD20-\uDD39\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33]|\uD808[\uDC00-\uDF6E]|\uD809[\uDC00-\uDC62]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|[\uD840-\uD868][\uDC00-\uDFFF]|\uD869[\uDC00-\uDED6]|\uD87E[\uDC00-\uDE1D])(?:[\$0-9A-Z_a-z\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u0523\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0621-\u065E\u0660-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0901-\u0939\u093C-\u094D\u0950-\u0954\u0958-\u0963\u0966-\u096F\u0971\u0972\u097B-\u097F\u0981-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C82\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0D02\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D28\u0D2A-\u0D39\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC\u0EDD\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F8B\u0F90-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u1099\u10A0-\u10C5\u10D0-\u10FA\u10FC\u1100-\u1159\u115F-\u11A2\u11A8-\u11F9\u1200-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u1676\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17B3\u17B6-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u1900-\u191C\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19A9\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BAA\u1BAE-\u1BB9\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1D00-\u1DE6\u1DFE-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u2094\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2C6F\u2C71-\u2C7D\u2C80-\u2CE4\u2D00-\u2D25\u2D30-\u2D65\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31B7\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FC3\uA000-\uA48C\uA500-\uA60C\uA610-\uA62B\uA640-\uA65F\uA662-\uA66F\uA67C\uA67D\uA67F-\uA697\uA717-\uA71F\uA722-\uA788\uA78B\uA78C\uA7FB-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA900-\uA92D\uA930-\uA953\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAC00-\uD7A3\uF900-\uFA2D\uFA30-\uFA6A\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE26\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1E\uDF30-\uDF4A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F\uDD00-\uDD15\uDD20-\uDD39\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F]|\uD808[\uDC00-\uDF6E]|\uD809[\uDC00-\uDC62]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|[\uD840-\uD868][\uDC00-\uDFFF]|\uD869[\uDC00-\uDED6]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF])*$/,
    // According to ES5 + Unicode 8.0.0
    REGEX_IDENTIFIER_ES5 = /^(?!(?:do|if|in|for|let|new|try|var|case|else|enum|eval|null|this|true|void|with|break|catch|class|const|false|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$)(?:[\$A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC])(?:[\$0-9A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC])*$/,
    REGEX_ES6_RESERVED_WORD = /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|await|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/,
    // ES3 reserved words that aren’t ES6 reserved words
    REGEX_ES3_RESERVED_WORD_EXCLUSIVE = /^(?:int|byte|char|goto|long|final|float|short|double|native|throws|boolean|abstract|volatile|transient|synchronized)$/,
    // Immutable properties of the global object
    REGEX_IMMUTABLE_PROPS = /^(?:NaN|Infinity|undefined)$/,
    REGEX_IDENTIFIER_WORD = /\b(?:[\$A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D])(?:[\$0-9A-Z_a-z\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF])*\b/,
    // According to ES6 + Unicode 5.1.0
    REGEX_IDENTIFIER_UNICODE5_WORD = /\b(?:[\$A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0523\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0621-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971\u0972\u097B-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D28\u0D2A-\u0D39\u0D3D\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC\u0EDD\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8B\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10D0-\u10FA\u10FC\u1100-\u1159\u115F-\u11A2\u11A8-\u11F9\u1200-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u1676\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19A9\u19C1-\u19C7\u1A00-\u1A16\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u2094\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2C6F\u2C71-\u2C7D\u2C80-\u2CE4\u2D00-\u2D25\u2D30-\u2D65\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31B7\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FC3\uA000-\uA48C\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA65F\uA662-\uA66E\uA67F-\uA697\uA717-\uA71F\uA722-\uA788\uA78B\uA78C\uA7FB-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA90A-\uA925\uA930-\uA946\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAC00-\uD7A3\uF900-\uFA2D\uFA30-\uFA6A\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1E\uDF30-\uDF4A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F\uDD00-\uDD15\uDD20-\uDD39\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33]|\uD808[\uDC00-\uDF6E]|\uD809[\uDC00-\uDC62]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|[\uD840-\uD868][\uDC00-\uDFFF]|\uD869[\uDC00-\uDED6]|\uD87E[\uDC00-\uDE1D])(?:[\$0-9A-Z_a-z\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u0523\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0621-\u065E\u0660-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0901-\u0939\u093C-\u094D\u0950-\u0954\u0958-\u0963\u0966-\u096F\u0971\u0972\u097B-\u097F\u0981-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C82\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0D02\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D28\u0D2A-\u0D39\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC\u0EDD\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F8B\u0F90-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u1099\u10A0-\u10C5\u10D0-\u10FA\u10FC\u1100-\u1159\u115F-\u11A2\u11A8-\u11F9\u1200-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u1676\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17B3\u17B6-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u1900-\u191C\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19A9\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BAA\u1BAE-\u1BB9\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1D00-\u1DE6\u1DFE-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u2094\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2C6F\u2C71-\u2C7D\u2C80-\u2CE4\u2D00-\u2D25\u2D30-\u2D65\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31B7\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FC3\uA000-\uA48C\uA500-\uA60C\uA610-\uA62B\uA640-\uA65F\uA662-\uA66F\uA67C\uA67D\uA67F-\uA697\uA717-\uA71F\uA722-\uA788\uA78B\uA78C\uA7FB-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA900-\uA92D\uA930-\uA953\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAC00-\uD7A3\uF900-\uFA2D\uFA30-\uFA6A\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE26\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1E\uDF30-\uDF4A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F\uDD00-\uDD15\uDD20-\uDD39\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F]|\uD808[\uDC00-\uDF6E]|\uD809[\uDC00-\uDC62]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|[\uD840-\uD868][\uDC00-\uDFFF]|\uD869[\uDC00-\uDED6]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF])*\b/,
    // According to ES5 + Unicode 8.0.0
    REGEX_IDENTIFIER_ES5_WORD = /\b(?!(?:do|if|in|for|let|new|try|var|case|else|enum|eval|null|this|true|void|with|break|catch|class|const|false|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$)(?:[\$A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC])(?:[\$0-9A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC])*\b/,
    REGEX_ES6_RESERVED_WORD_WORD = /\b(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|await|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)\b/,
    // ES3 reserved words that aren’t ES6 reserved words
    REGEX_ES3_RESERVED_WORD_EXCLUSIVE_WORD = /\b(?:int|byte|char|goto|long|final|float|short|double|native|throws|boolean|abstract|volatile|transient|synchronized)\b/,
    // Immutable properties of the global object
    REGEX_IMMUTABLE_PROPS_WORD = /\b(?:NaN|Infinity|undefined)\b/,
    // Zero-width characters that are allowed in IdentifierPart as per ES5
    REGEX_ZERO_WIDTH = /\u200C|\u200D/;
    
var UNICODE_LETTERS_REGEXP = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;



var DEFAULT_VALUE_KEYWORDS = { 
    "now" : function() {
        return Date.now();
    }, 
    "sysdate" : function(typ, format) {
        var dt = new Date();
        dt.setHours(0,0,0,0);
        if (typ ===  'string') {
            return dt.format(format||"yyyy-MM-dd");
        }
        return dt;
    }, 
    "systimestamp": function(typ, format) {
        var dt = new Date();
        if (typ ===  'string') {
            return dt.format(format||"yyyy-MM-dd HH:mm:ssZ");
        }
        return dt;
    }, 
    "sysdatetime": function(typ, format) {
        var dt = new Date();
        if (typ ===  'string') {
            return dt.format(format||"yyyy-MM-dd HH:mm:ssZ");
        }
        return dt;
    }, 
    "today": function(typ, format) {
        var dt = new Date();
        dt.setHours(0,0,0,0);
        if (typ ===  'string') {
            return dt.format(format||"yyyy-MM-dd");
        }
        return dt;
    }, 
    "yesterday": function(typ, format) {
        var dt = new Date();
        dt.setHours(0,0,0,0);
        dt.setTime(dt.getTime() - 24*60*60*1000);
        if (typ ===  'string') {
            return dt.format(format||"yyyy-MM-dd");
        }
        return dt;
    }, 
    "tomorrow":function(typ, format) {
        var dt = new Date();
        dt.setHours(0,0,0,0);
        dt.setTime(dt.getTime() + 24*60*60*1000);
        if (typ ===  'string') {
            return dt.format(format||"yyyy-MM-dd");
        }
        return dt;
    }, 
    "systime":function(typ, format) {
        var dt = new Date();
        dt.setYear(0);
        dt.setMonth(0);
        dt.setDate(1);
        if (typ ===  'string') {
            return dt.format(format||"HH:mm:ss");
        }
        return dt;
    },
    "sysyear":function(typ, format) {
        var dt = new Date();
        dt = dt.getYear();
        if (typ ===  'string') {
            return "" + dt;
        }
        return dt;
    },
    "sysmonth":function(typ, format) {
        var dt = new Date();
        dt = dt.getMonth();
        if (typ ===  'string') {
            return "" + dt;
        }
        return dt;
    },
    "sysday":function(typ, format) {
        var dt = new Date();
        dt = dt.getDate();
        if (typ ===  'string') {
            return "" + dt;
        }
        return dt;
    }
};



/**
* 
* @type Array&lt;String&gt;
*/
var JS_ES2015_USED_KEYWORDS = [
            'var', 'let', 'const', 
            'if', 'else',
            'function', 'new', 'this', 'async',
            'for', 'in', 'of', 'do', 'while',
            'return', 'new', 'break', 'continue', 
            'try', 'catch', 'finally',
            'switch', 'case', 'default',
            'throw', 'with', 'delete', 'await', 'yield',
            'import', 'export', 'from', 'as',
            'class', 'extends', 'static'
        ];
        
/**
* 
* @type Array&lt;String&gt;
*/
var JS_ES2015_USED_KEYWORDS_EXT = [
            'var', 'let', 'const', 
            'if', 'else',
            'function', 'new', 'this', 'async',
            'for', 'in', 'of', 'do', 'while',
            'return', 'new', 'break', 'continue', 
            'try', 'catch', 'finally',
            'switch', 'case', 'default',
            'throw', 'with', 'delete', 'await', 'yield',
            'import', 'export', 'from', 'as',
            'class', 'extends', 'static', 'interface', 'implements',
            'type'
        ];
        
/**
* 
* @type Array&lt;String&gt;
*/
var JS_USED_KEYWORDS = [
            'var', 
            'if', 'else',
            'function', 'new', 'this',
            'for', 'do', 'while', 
            'return', 'new', 'break', 'continue', 
            'try', 'catch', 'finally',
            'switch', 'case', 'default',
            'throw', 'with', 'in', 'delete', 'await', 'yield'
        ];


//var JS_KEYWORDS = JS_ES2015_USED_KEYWORDS;

var JS_KEYWORDS = JS_ES2015_USED_KEYWORDS_EXT;

//var JS_KEYWORDS = JS_USED_KEYWORDS;


/**
 * 
 * @type Array
 */
var JS_QUOTES = ["'", '"'];
/**
 * 
 * @type Array
 */
var JS_QUOTE_ESCAPES = ["\\"];
/**
 * 
 * @type RegExp
 */
var JS_QSTRING = getSQuotedStringRe(JS_QUOTES,
        JS_QUOTE_ESCAPES, false, qstringKey);
        
var STRING_LITERAL_RE = getSQuotedStringRe(["'", '"'],
        ["\\"], false, qstringKey);


function VariablesScope() {
    this._global = [];
    this._variables = {};
}


VariablesScope.prototype.__CLASS__ = VariablesScope;
VariablesScope.__CLASS__ = VariablesScope;
VariablesScope.__CLASS_NAME__ = "VariablesScope";

VariablesScope.prototype.getValue = function(name) {
    var v = this._variables[name];
    if (typeof v !== 'undefined') {
        return v;
    }
    if (isArray(this._global)) {
        var vars;
        for (var i = this._global.length - 1; i >= 0; i--) {
            v = this._global[i].getValue(name);
            if (typeof v !== 'undefined') {
                return v;
            }
        }
    } else if (isPlainObject(this._global)) {
        return this._global.getValue ? this._global.getValue(name) : this._global[name];
    }
    return undefined;
};



VariablesScope.prototype.addGlobal = function(vars) {
    if (vars instanceof this.__CLASS__) {
        if (!isArray(this._global)) {
            if (this._global) {
                this._global = [ this._global ];
            } else {
                this._global = [];
            }
        }
        this._global[this._global.length] = vars;
    }
};
/**
 * 
 * @param {type} v
 * @returns {VariablesScope}
 */
VariablesScope.prototype.put = function(v) {
    var name;
    if (arguments.length === 1 && v instanceof NamedFunction || v instanceof Class || v instanceof Variable) {
        name = v.getName();
        if (name) {
            this._variables[name] = v;
        }
    } else if (typeof v === 'string') {
        var e;
        if (arguments.length === 1  || !((e=arguments[1]) instanceof StatementElt && e.isExpression())) {
            throw new Error("Incorrect arguments");
        }
        this._variables[v] = arguments[1];
    } else if (isPlainObject(v)) {
        var count = arguments.length, args = [].slice.call(arguments), e;
        for (var i = 0; i < count; i++) {
            e = args[i];
            if (e instanceof NamedFunction || e instanceof Class || e instanceof Variable) {
                name = e.getName();
                if (name) {
                    this._variables[name] = e;
                }
            } else if (e instanceof VariablesScope) {
                if (!this._global) {
                    this._global = [];
                } else if (!isArray(this._global)) {
                    this._global = [this._global];
                }
                this._global[this._global.length] = e;
            }
        }
    }
    return this;
};

function ExpressionParser() {    
}

ExpressionParser.__CLASS__ = ExpressionParser;

ExpressionParser.__CLASS_NAME__ = "ExpressionParser";


function StatementParser() {    
}

StatementParser.__CLASS__ = StatementParser;

StatementParser.__CLASS_NAME__ = "StatementParser";



(function(EParser, SParser, grammar) {
    
    var ns = typeof SereniX !== 'undefined' && isPlainObject(SereniX) === 'object' ? SereniX.prog||window: window;
    var Expression = ns.Expression||Expression, 
            Reference = ns.Reference||Reference,
            OCRef = ns.OCRef||OCRef,
            Index = ns.Index||Index,
            OCIndex = ns.OCIndex||OCIndex,
            NullCoalescing = ns.NullCoalescing||NullCoalescing,
            Statement = ns.Statement||Statement,
            EmptyStatement = ns.EmptyStatement||EmptyStatement,
            QString = ns.QString||QString,
            EQString = ns.EQString||EQString,
            QuotedHintStatement = ns.QuotedHintStatement||QuotedHintStatement,
            StatementElt = ns.StatementElt||StatementElt,
            IComment = ns.IComment||IComment,
            Comment = ns.Comment||Comment,
            Comments = ns.Comments||Comments,
            Conditional = ns.Conditional||Conditional,
            Try = ns.Try||Try,
            Throw = ns.Throw||Throw,
            Return = ns.Return||Return,
            Break = ns.Break||Break,
            Continue = ns.Continue||Continue,
            Switch = ns.Switch||Switch,
            Case = ns.Case||Case,
            Block = ns.Block||Block,
            If = ns.If||If,
            IfCase = ns.IfCase||IfCase,
            For = ns.For||For,
            ForIn = ns.ForIn||ForIn,
            ForOf = ns.ForOf||ForOf,
            Declaration = ns.Declaration||Declaration,
            SDeclaration = ns.SDeclaration||SDeclaration,
            Variable = ns.Variable||Variable,
            Class = ns.Class||Class,
            ClassBody = ns.ClassBody||ClassBody,
            Interface = ns.Interface||Interface,
            InterfaceBody = ns.InterfaceBody||InterfaceBody,
            DName = ns.DName||DName,
            EList = ns.EList||EList,
            SkipableElt = ns.SkipableElt||SkipableElt,
            ODAssign = ns.ODAssign||ODAssign,
            ODVariables = ns.ODVariables||ODVariables,
            ADVariables = ns.ADVariables||ADVariables,
            ADAssign = ns.ADAssign||ADAssign,
            SType = ns.SType||SType,
            DataTypeToken = ns.DataTypeToken||DataTypeToken,
            NamedType = ns.NamedType||NamedType,
            UnionType = ns.UnionType||UnionType,
            ArrowFunction = ns.ArrowFunction||ArrowFunction,
            Variable = ns.Variable||Variable,
            ComputedName = ns.ComputedName||ComputedName,
            EComputedName = ns.EComputedName||EComputedName,
            Field = ns.Field||Field,
            Method = ns.Method||Method,
            Getter = ns.Getter||Getter,
            Setter = ns.Setter||Setter,
            Property = ns.Property||Property,
            Constructor = ns.Constructor||Constructor,
            Param = ns.Param||Param,
            Params = ns.Params||Params,
            DefaultExport = ns.DefaultExport||DefaultExport,
            ImportElements = ns.ImportElements||ImportElements,
            ImportSelection = ns.ImportSelection||ImportSelection;
            
    var exprRef = "\\k<expr>";
    var exprKey = "?<expr>";
    var nameKey = "?<name>";
    //var qstringKey = "?<qstring>";
    var qstringRef = "\\k<qstring>";
    var refRef = "\\k<ref>";
    var nameRef = "\\k<name>";
    var argsRef = "\\k<args>";
    var indicesRef = "\\k<indices>";


    var qstring = getSQuotedStringRe(["'", '"', '`'],
            SERENIX_QUOTES_ESCAPES||SERENIX_DEFAULT_QUOTES_ESCAPES||[ '\\', 'quote' ], false, qstringKey);
    var _int = "0[xX][a-fA-F0-9]|0[0-7]*|\\d+";
    var litteral = "(?<litteral>(?:(?:\\+|\\-)?(?:0[xX][a-fA-F0-9]+|0[0-7]*|\\d+(?:[\\.]\\d+)?))|false|true|null|undefined)",
        name = "(" + nameKey + "[a-zA-Z_$][a-zA-Z_$0-9]*(?:[\\.][a-zA-Z_$][a-zA-Z_$0-9]*)*)";

    var args = "(?<args>\\((?:\\s*" + exprRef + "\\s*(?:[,]\\s*" + exprRef + "\\s*)*)?\\))";

    var indices = "(?<indices>\\[\\s*(?:" + exprRef +  ")\\s*\\])";

    var ref = "(?<ref>" + "(?:"+qstring+"[\\.])?" + name +"\\s*(?:"+ args + "|" + indices + ")*\\s*" + "(?:[\\.]" + nameRef + "\\s*(?:" + argsRef +'|' + indicesRef + ")*)*)";



    var postfix = "(?:" + ref + "(?:\\+{2}|\\-{2}))";
    var prefix = "(?:(?:\\+{1,2}|\\-{1,2})\\s*" + refRef + "|(?:(?:!|\\^)\\s*" + exprRef + "))";

    var oper = "(?<operator>\\+|\\-|\\*{1,2}|\\/|%|&&|\\|{2}|>>>|>>|<<|>|>=|<|<=|===|==|!==|!=|=|&|\\|)";

    var operators = [ "+", "-", "*", "**", "/", "%", "&&", "||", ">>>", ">>", "<<", ">", ">=", "<", "<=", "===", "==", "!==", "!=", "=", "&", "|" ];
    var operatorsList = operators;
    var operation = "(?<operation>(?<left>" + exprRef + ")(?:\\s*" + oper + "\\s*(?<right>" + exprRef + ")\\s*)+)";

    var _if = "(?<conditional>" + exprRef + "\\s*\\?\\s*" + exprRef + "\\s*\\:\\s*" + exprRef + ")";

    var grouping = "(?:\\(\\s*" + exprRef + "\\s*\\))";

    var nonGroupedExpr = litteral
            + "|" + postfix
            + "|" + prefix                        
            + "|" + operation 
            + "|" + _if
            + "|" + refRef
            + "|" + qstringRef                         
             ;

    var expr = "(" + exprKey
            + nonGroupedExpr
            + "|" + grouping
            + ")";

    var paramDelim = ',';
    var statementChainSymbol = ',';
    var declarationChainSymbol = ',';
    var statementEnder = ';';
    var blockEnder = '}';
    /**
     * The list of quoted hint statements. 
     * <p>A quoted hint statement is a quoted string that 
     * corresponds to or is a predefined statement.</p>
     * <p>In javascript 'use strict' is a quoted hint statement.</p>
     * <p>A quoted hint statement can be a quoted string, a plain 
     * object with 'tokens' property and optionaly 'quote' or 
     * 'quotes' property.</p>
     * <p>When 'quote' or 'quotes' property is not setted, any 
     * quote is accepted when cheking if a quoted string is a 
     * quoted hint statement, other wise only specified or quotes 
     * are accepted.</p>
     * @type Array&lt;String|Object&gt;
     */
    var quotedHintStatements = [ { tokens : [ 'use', 'strict'], quotes: ['\'']}];
    var newLineEndStatementRe = /(?:[ ]|\t|\v|\b|\0)*(?:\n|(?:\r\n?))+\s*/g;
    var statementEnderSkipables = { ';' : true, '}': false };
    function unclosedStatementEnd(str, i, lastLineNum, lineNum) {
        return lastLineNum < lineNum || i >= str.length;
    };
    /**
     * 
     * <p>When a statement ender is a function, it should return a plain object with the following properties/fields:</p>
     * <ul>
     * <li><b>ender</b>: the string symbol/marker that ends the statement. This property is optional;</li>
     * <li><b>lastIndex</b>: the position/index where the effective statement ends.</li>
     * <li><b>index</b>: the position/index of the ender when the statement is ended by an ender, otherwise the position of the next statement.</li>
     * </ul>
     * @type Array&lt;String|Function|RegExp&gt;
     */
    var statementEnders = [
        ';',
        '}', 
        unclosedStatementEnd
    ];
    var expressionAsStatement = true;

    var chainedExpressionsDelim = ',';

    var keywords = "break case catch class const continue debugger default delete do else export extends finally for function if import in instanceof let new return static super switch this throw try typeof var void while with yield".split(" ");
    var notKeywordKey = false;
    var textPatternQuote = '`', qspatternKey, qspattern, qspatternRe;
    var objectSimplifiedSyntax = true;
    var regexps = {
        "litteral": new XRegExp("(?:(?:\\+|\\-)?(?:0[xX][a-fA-F0-9]*|0[0-7]*|\\d+(?:[\\.]\\d+)?))|\\b(?:false|true|null|undefined)\\b", "g"),
        "qstring": new XRegExp(qstring, "g"),
        "name": new XRegExp("[a-zA-Z_$][a-zA-Z_$0-9]*(?:[\\.][a-zA-Z_$][a-zA-Z_$0-9]*)*", "g"),
        "simple-name": new XRegExp("[a-zA-Z_$][a-zA-Z_$0-9]*", "g"),
        //"simple-name": new XRegExp("\\b(?:" + VARIABLE_ID_RE + ")\\b", "g"),
        "one-arg-arrow-func": /([a-zA-Z_$][a-zA-Z_$0-9]*)\s*=>[ \t\v\b\0]*/g,
        "key": new XRegExp("[a-zA-Z$_][a-zA-Z$_0-9]*|(?:[0-9]|[1-9][0-9]+(?:[\\.][0-9]+)?)|(?:[\\.][0-9]+)|1[eE](?:\\+|-)?(?:0|[1-9][0-9]*)|0[xX][0-9a-fA-F]+|0[0-7]+|(?:" + qstring + ")", "g"),
        //"key": new XRegExp("\\b(?:" + VARIABLE_ID_RE + "|(?:[0-9]|[1-9][0-9]+(?:[\\.][0-9]+)?)|(?:[\\.][0-9]+)|1[eE](?:\\+|-)?(?:0|[1-9][0-9]*)|0[xX][0-9a-fA-F]+|0[0-7]+|(?:" + qstring + ")" + ")\\b", "g"),
        "increment": /(?:\+{1,2}|\-{1,2})/g,
        "new": /\bnew\b/g,
        "async": /\basync\b/g,
        "finally": /\bfinally\b/g,
        "function": new XRegExp("function\\b", "g"),
        "class": /\bclass\b/g,
        "binary-operators": new XRegExp("\\+=|\\-=|\\*{1,2}=|\\/=|%=|&{1,2}=|\\|{1,2}=|>>>=|>>=|<<=|^=|\\?\\?=|\\+{1,2}|\\-{1,2}|\\*{1,2}|\\/|%|&&|\\|{2}|>>>|>>|<<|>=|<=|>|<|===|==|!==|!=|=|&|\\||\\bin\\b|\\binstanceof\\b", "g"),
        "operators": new XRegExp("\\+{1,2}|\\-{1,2}|\\*{1,2}|\\/|%|&&|\\|{2}|>>>|>>|<<|>=|<=|>|<|===|==|!==|!=|=|&|\\||\\bin\\b|\\binstanceof\\b", "g"),
        "destruct-operators": new XRegExp("\\+{1,2}|\\-{1,2}|\\*{1,2}|\\/|%|&&|\\|{2}|>>>|>>|<<|>=|<=|>|<|===|==|!==|!=|&|\\||\\bin\\b|\\binstanceof\\b", "g"),
        "assign-operators" : new XRegExp("=|\\+=|\\-=|\\*{1,2}=|\\/=|%=|&{1,2}=|\\|{1,2}=|>>>=|>>=|<<=|^=|\\?\\?=", "g"),
        "prefix-operators" : /\+{1,2}|\-{1,2}|!|~|\btypeof\b|\bvoid\b|\bdelete\b|\bawait\b|\byield\b|\byield\*/g,
        "arrow-function": /(?:\(\s*((?:[a-zA-Z$_][a-zA-Z$_0-9]*)?(?:\s*[,]\s*(?:[a-zA-Z$_][a-zA-Z$_0-9]*))*)?\s*\)|\s*([a-zA-Z$_][a-zA-Z$_0-9]*))\s*=>/g
    };
    var keyDelim = ':'; 
    var entryCloser = ',';
    var labelDelim = ':';
    var statementCloser = ',';
    
    
    if (textPatternQuote) {
        qspatternKey = 'textpattern';
        qspattern = getSQuotedStringRe([textPatternQuote],
                SERENIX_QUOTES_ESCAPES||SERENIX_DEFAULT_QUOTES_ESCAPES||[ '\\', 'quote' ], false, qspatternKey);
                
        qspatternRe = new XRegExp(qspattern, "g");
    }
    /**
     * 
     * @param {QString} qstring
     * @returns {String} 
     */    
    function getQuotedHintStatement(qstring) {
        function isQuoted(quotes, qstr) {
            if (!quotes) {
                return true;
            }
            count = quotes.length;
            for (var k = 0; k < count; k++) {
                if (qstr[0] === quotes[k] && qstr[0] === qstr[qstr.length - 1]) {
                    return true;
                }
            }
            return false;
        }
        var hints = quotedHintStatements, n = hints.length, 
                hint, qstr = qstring.getString(), ok, count, 
                _toks, tokens;
        for (var i = 0; i < n; i++) {
            hint = hints[i];
            if (typeof hint === 'string') {
                if (qstr === hint) {
                    return qstr;
                }
            } else if (hint.tokens) {
                tokens = hint.tokens;
                if (isQuoted(hint.quotes, qstr)) {
                    _toks = qstr.substring(1,qstr.length - 1).split(/\s+/);                            
                    if ((count = _toks.length) === tokens.length) {
                        ok = true;
                        for (var k=0; k < count; k++){
                            if (_toks[k] !== tokens[k]) {
                                ok = false;
                                break;
                            }
                        }
                        if (ok) {
                            return qstr;
                        }
                    }
                }
            } else {
                notSupported("Case not supported"); //throw exception
            }
        }
        return null;
    }

    var lineNum = -1, lineOffset = 0, tabsCount = 0, tabSpaces = 4, newLine = ['\n' , '\r\n'];
    //The conditionals stack
    var _conditionals = [];

    function isNewLine(str, i, n, nl, delims) {
        if (i >= n) {
            return false;
        }
        for (var k = 0; k < delims; k++) {
            nl = newLine[k];
            if (str.startsWith(nl, i)) {                            
                i += nl.length;
                return nl;
            }
        }
        return false;
    } 

    function initLine(str,end, n, nl) {
        var _newLine;
        if (nl) {
            _newLine = isArray(nl) ? nl : [nl];
        } else if (!newLine) {
            _newLine = newLine = ['\n' , '\r\n'];
        } else if (typeof newLine === 'string') {
            _newLine = newLine = [ newLine ];
        } else if (!isArray(newLine)) {
            incorrectArgs(); //throw exception
        }
        if (typeof n === 'undefined' || n === null || n < 0) {
            n =str.length;
        }
        if (typeof end === 'undefined' || end === null || end < 0) {
            end = 0;
        }
        lineNum = n === 0 ?  0 : 1;
        lineOffset = 0;
        if (n === 0) {
            return;
        }
        var i = 0, nl, delims = _newLine.length, found;                
        while (i <= end) {
            if ((nl = isNewLine(str, i, n, _newLine, delims))) {                        
                i += nl.length;
                lineNum++;
                lineOffset = i;
            } else {                        
                i++;
            }
        }
    };
    /**
     * Returns the column ordinal number of the given index
     * @private
     * @param {type} i The index
     * @returns {Number}
     */
    function getColumn(i) {
        return i + (tabsCount * (tabSpaces - 1)) - lineOffset + 1;
    }

    var skipSpaces = function (str, i, n, spaces) {
        if (arguments.length > 2 && typeof arguments[2] !== 'number') {
            if (typeof arguments[2] !== 'string' && !isArray(arguments[2])) {
                incorrectArgs(); //throw e<ception
            } else {
                spaces = arguments[2];
                n = str.length;
            }
        }
        if (typeof n=== 'undefined' || n === null) {
            n = str.length;
        }
        if (!spaces) {
            spaces = " \t\v\b\0";
        }
        var nl, delims = newLine.length;
        while (i < n ) {
            if ((nl = isNewLine(str, i, n, newLine, delims))) {
                i += nl.length;
                lineNum++;
                lineOffset = i;
                tabsCount = 0;
            } else if (spaces.indexOf(str[i]) >= 0) {
                if (str[i] === '\t') {
                    tabsCount++;
                }
                i++;
            } else {
                break;
            }
        }
        return i;
    };



    function unexpectedEnd() {
        throw new Error("Unexpected end");
    }
    /**
    * Each call of unexpectedChar() function, throws an unexpected character exception.
    * @param {char} [ch]
    * @param {Number} [num]
    * @param {Number} [column]
    * @param {String} [msg="Unexpected character"]
    * @returns {undefined}
    * @throws {Error} 
    */
   function unexpectedChar(ch, num, column, msg) {
       var a = arguments, 
           len = a.length, index = false, lineNum = false;
           m;
       if (len === 2 && typeof num ==="number") {
           index = num;

       } else if (len === 3 && typeof num ==="number" && typeof column ==="string") {
           index = num;
           var m = msg;
           msg =  column;
           column = m;        
       } else if (len === 4) {
           lineNum = num;
           m = (len > 1 && typeof a[1] === 'string' ? a[1]
               : (len > 3 && typeof a[3] === 'string' ? a[3] : ""))||"Unexpected character";
            if (typeof a[3] === 'number') {
                index = a[3];
            }
       }  else if (len > 4) {
           lineNum = num;
           m = (len > 1 && typeof a[1] === 'string' ? a[1]
               : (typeof a[4] === 'string' ? a[4] : ""))||"Unexpected character";
            if (typeof a[3] === 'number') {
                index = a[3];
            }
       }
       if (!m) m = m = "Unexpected character";
       if (len > 0) {
           m += ": '" + ch + "'";
       }
       if (typeof lineNum !== 'undefined' && lineNum !== false) {
           m += ' at line ' + num;
           if (typeof column ==="number") {
               m += " "+ (index !== false? "," : "and") + " column " + column;
           }
           if (index !== false) {
                m += ' and index ' + index;
            }
       } else if (index !== false) {
           m += ' at index ' + index;
       }
       throw new Error(m);
    }

    /**
    * Each call of unexpectedChar() function, throws an unexpected character exception.
    * @param {char} ch
    * @param {char} [found]
    * @param {Number} [num]
    * @param {Number} [column]
    * @param {String} [msg="Expected character"]
    * @returns {undefined}
    * @throws {Error} 
    */
   function expectedChar(ch, found, num, column, msg) {
       var a = arguments, 
           len = a.length, index = false, lineNum = false;
           m;
       if (len === 2 && typeof num ==="number") {
           index = num;

       } else if (len === 3 && typeof num ==="number") {
           index = num;

       } else if (len === 4 && typeof num ==="number" && typeof column ==="string") {
           index = num;
           var m = msg;
           msg =  column;
           column = m;        
       } else {
           lineNum = num;
           m = (len > 1 && typeof a[1] === 'string' ? a[1]
               : (len > 3 && typeof a[3] === 'string' ? a[3] : ""))||"Unexpected character";
       }
       if (!m) m = m = "Expected character";
       if (len > 0) {
           m += " '" + ch + "'";
       }
       if (found) {
           m += " but found '" + found + "'";
       }
       if (typeof lineNum !== 'undefined' && lineNum !== false) {
           m += ' at line ' + num;
           if (typeof column ==="number") {
               m += " and column " + column;
               if (index !== false) {
                    m += ' (index ' + index + ')';
                }
           } else if (index !== false) {
                m += ' and index ' + index;
            }
       } else if (index !== false) {
           m += ' at index ' + index;
       }
       throw new Error(m);
    }
    /**
     * Each call of unexpectedChar() function, throws an unexpected character exception.
     * @param {String} kw  The expected keyword
     * @param {String|char} found
     * @param {Number} num
     * @param {Number} column
     * @param {String} [msg="Expected keyword"]
     * @returns {undefined}
     * @throws {Error} 
     */
    function expectedKeyword(kw, found, num, column, msg) {
       var a = arguments, 
           len = a.length, index = false, lineNum = false;
           m;
       if (len === 2 && typeof num ==="number") {
           index = num;

       } else if (len === 3 && typeof num ==="number") {
           index = num;

       } else if (len === 4 && typeof num ==="number" && typeof column ==="string") {
           index = num;
           var m = msg;
           msg =  column;
           column = m;        
       } else {
           lineNum = num;
           m = (len > 1 && typeof a[1] === 'string' ? a[1]
               : (len > 3 && typeof a[3] === 'string' ? a[3] : ""))||"Expected keyword";
       }
       if (!m) m = m = "Expected keyword";
       if (len > 0) {
           m += " '" + kw + "'";
       }
       if (found) {
           m += " but found '" + found + "'";
       }
       if (typeof lineNum !== 'undefined' && lineNum !== false) {
           m += ' at line ' + num;
           if (typeof column ==="number") {
               m += " and column " + column;
               if (index !== false) {
                    m += ' (index ' + index + ')';
                }
           } else if (index !== false) {
                m += ' and index ' + index;
            }
       } else if (index !== false) {
           m += ' at index ' + index;
       }
       throw new Error(m);
   }
    /**
     * Parses expression from the offset specified as number (argument i) or as field of the context/options (ctx.offset).
     * <h3>Syntax:</h3>
     * <ul>
     * <li>parseExpression(str: string, ctx: Object)
     * <ul>
     * <li>ctx.offset specifies where start to parse expression. If not setted, 
     * the parsing will start at the position/offset 0</li>
     * <li>The array of string field ctx.stop specifies when to stop parse 
     * expression. When one element of the array is encountered, the parse 
     * stop.</li>
     * </ul></li>
     * <li>parseExpression(str: string, i: number, stop: Array&lt;string&gt;)<p></p></li>
     * <li>parseExpression(str: string, stop: Array&lt;string&gt;, i: number)<p></p></li>
     * <li>parseExpression(str: string, i: number)<p></p></li>
     * <li>parseExpression(str: string, stop: Array&lt;string&gt;)<p></p></li>
     * <li>parseExpression(str: string, ctx: Object, strictOperatorStop: boolean)
     * <ul>
     * <li>ctx.offset specifies where start to parse expression. If not setted, 
     * the parsing will start at the position/offset 0</li>
     * <li>The array of string field ctx.stop specifies when to stop parse 
     * expression. When one element of the array is encountered, the parse 
     * systematically stop when the element is not and operator. There are three 
     * possibilities when the element is an operator
     * <ul>
     * <li>The stop element ends the string or it's followed by spaces and ends with parameter type symbol (ctx.parameterSymbol)  or it's followed by spaces that ends the string ends: systematically stop</li>
     * <li>The value of the argument strictOperatorStop is true: the parse systematically stop
     * systematically stop</li>
     * <li>The value of the argument strictOperatorStop is false: the parse continues</li>
     * </ul>
     * </li>
     * </ul></li>
     * </ul>
     * @param {type} str
     * @param {type} ctx
     * @returns {Object}
     */
    function parseExpression(str, ctx) {
        var offset, stop, result = _arrowOrGrp = {}, 
                parameterTypeSymbol, strictOperatorStop;
        if (arguments.length >= 3 && !isPlainObject(ctx)) {
            if (typeof ctx === 'number') {
                offset = ctx;
                stop = arguments[2];
            } else if (isArray(ctx)) {
                offset = arguments[2];
                stop = ctx;
            }
            ctx = undefined;
        } else if (isPlainObject(ctx)) {
            offset = ctx.offset||0;
            stop = ctx.stop;
            parameterTypeSymbol = ctx.parameterTypeSymbol;
            if (arguments.length > 2) {
                var a = arguments[2];
                if (a instanceof Boolean) {
                    a = a.valueOf();
                }
                if (typeof a === 'boolean') {
                    strictOperatorStop = a;
                }
            }
        } else {
            if (typeof ctx === 'number') {
                offset = ctx;
            } else if (isArray(ctx)) {
                stop = ctx;
                offset = 0;
            } else {
                offset = 0;
            }
            ctx = undefined;
        }

        var n = str.length, 
            i = skipSpaces(str, offset, n), 
            ch,
            litteral = regexps.litteral,
            qstring = regexps.qstring, 
            //operators = regexps.operators,
            operators = regexps['binary-operators'],
            func = regexps['function'], 
            _class = regexps['class'],
            _async = regexps['async'],
            arrowFunc = regexps['arrow-function'],
            oneArgArrowFunc = regexps['one-arg-arrow-func'],
            prefixOperators = regexps["prefix-operators"],
            match,
            prefixed = false, 
            left = false,
            start = i,
            lastIndex,
            lastLineNum = lineNum,
            operand,
            o;

        var ns = typeof SereniX !== 'undefined' && isPlainObject(SereniX) === 'object' ? SereniX.prog||window: window;
        var Expression = ns.Expression||Expression, 
                Operation = ns.Operation||Operation,
                UnaryOperation = ns.UnaryOperation||UnaryOperation,
                IComment = ns.UnaryOperation||IComment,
                Conditional = ns.Conditional||Conditional;
        /**
         * 
         * @param {String} str
         * @param {Number} i The current position : position of the prefix operator
         * @param {String} op  Prefix operator
         * @returns {ctx.object|serenix_statement_parser_L342.processOperation.o|serenix_statement_parser_L342.finalize.result|type|ns.ChainedExpressions|Expression|i.object|Object|unresolved|serenix_statement_parser_L342.finalize.serenix_statement_parserAnonym$13}
         */
        function processPrefixOperator(str, i, op) {
            i = prefixOperators.lastIndex;
            var offset = ctx.offset;
            ctx.offset = skipSpaces(str, i, n);
            var e = parseExpression(str, ctx);
            if (e instanceof UnaryOperation) {
                var cmp = compareOperator(getOperatorKey(op, "prefix"), getOperatorKey(e.getOperator, e.isPrefixed() ? "prefix": "postfix"));
                if (cmp <= 0) {
                    e = Expression.getInstance({type: "prefix", operator: op, member: e});
                } else {
                    e.setMember(Expression.getInstance({type: "prefix", operator: op, member: e.getMember()}));
                }
            } else if (e instanceof LROperation) {
                var cmp = compareOperator(getOperatorKey(op, "prefix"), getOperatorKey(e.getOperator));
                if (cmp <= 0) {
                    e = Expression.getInstance({type: "prefix", operator: op, member: e});
                } else {
                    e.setLeft(Expression.getInstance({type: "prefix", operator: op, member: e.getLeft()}));
                }
            } else if (e instanceof Operation) { //TODO: finalize this case
                var cmp = compareOperator(getOperatorKey(op, "prefix"), getOperatorKey(e.getOperator));
                if (cmp <= 0) {
                    e = Expression.getInstance({type: "prefix", operator: op, member: e});
                } else if (typeof e.setMember === 'function') {
                    e.setMember(0, Expression.getInstance({type: "prefix", operator: op, member: e.getLeft()}));
                } else {
                    var eleft = e.removeMember(0);
                    if (typeof e.insertMember === 'function') {
                        e.insertMember(0, Expression.getInstance({type: "prefix", operator: op, member: eleft()}));
                    } else {
                        e.addMember(0, Expression.getInstance({type: "prefix", operator: op, member: eleft()}));
                    }
                }
            } else {
                e = Expression.getInstance({type: "prefix", operator: op, member: e});
            }
            i = ctx.index;
            ctx.offset = offset;
            //return finalize(ctx, endExpression(str, i, stop, e, start), start); 
            return e;
        }
        var _cmt, commented = false, _endSymbol = false, _endSymbolIndex, startLineNum;
        var  _arrowOrGrp;
        while (i < n) {
            if (left) {
                commented = false;
                if ((_cmt = _processComments(str, skipSpaces(str, i, n), n))) {
                    commented = true;
                    i = _cmt.index;
                    if (lastLineNum === _cmt.startLineNum) {
                        if (_cmt.object instanceof Comment) {
                            left.setInlineComment(_cmt.object);
                            _cmt = null;
                        } else {
                            left.setInlineComment(_cmt.object.remove(0));
                        }
                    }                            
                    if (i >= n) {
                        break;
                    }
                }
                //if match an operator symbol
                if ((match = regexMatch(operators, str, i))) {
                    if (_cmt) {
                        left.setEndComment(_cmt.object);
                        _cmt = null;
                    }
                    match = match[0];
                    if (stop && stop.indexOf(match) >= 0) {
                        if (strictOperatorStop) {
                            break;
                        } else {
                            _endSymbolIndex = skipSpaces(str, operators.lastIndex, n);
                            if ((_cmt = _processComments(str, _endSymbolIndex, n))) {
                                _endSymbolIndex = _cmt.index;
                                _cmt = _cmt.object;
                                //TODO
                            }
                            if (_endSymbolIndex === n || (_endSymbolIndex === n - 1 && str[_endSymbolIndex] === parameterTypeSymbol)) {
                                break;
                            } else {
                                _endSymbol = true;
                            }
                        }
                    }
                    i = skipSpaces(str, operators.lastIndex, n);                            
                    if (match === '++' || match === '--') {
                        if (commented) {
                            if (lastLineNum < lineNum) {
                                break;
                            } else {
                                throw new Error("Unexpected operator '" + match + "'");
                            }
                        }
                        left = { type: "postfix", operator: match, member: left,endComment: _cmt };
                        _cmt = null;
                    } else {
                        if ((_cmt = _processComments(str, i, n))) {
                            commented = true;
                            i = _cmt.index;
                            startLineNum = _cmt.startLineNum;
                            _cmt = _cmt.object;

                            if (lastLineNum === startLineNum) {
                                //TODO

                                _cmt = null;
                            }                            
                            if (i >= n) {
                                break;
                            }
                        }
                        try {
                            return processOperation(str, _endSymbol ? _endSymbolIndex : i, n, ctx, left, match, stop, start, _cmt);
                        } catch (e) {
                            if (_endSymbol) {
                                i = _endSymbolIndex;
                               break;
                            }  else {
                                throw e;
                            }
                        }
                    }                            
                } else if (str[i] === '?') { //conditional ternary operator
                    if (_cmt) {
                        left.setEndComment(_cmt.object);
                        _cmt = null;
                    }
                    return processConditional(str, i, n, left, ctx, stop, start);
                } else if (stop && stop.length) {
                    break;
                } else {    
                    unexpectedChar(ch, i); //throw exception
                }
            } else if (prefixed) {
                if (str.startsWith("++", i) || str.startsWith("--", i)) {
                    o = {  operator: str.startsWith("++", i) ? "++": "--", type: "prefix" };
                    operand.member = o;
                    operand = o;
                    i += 2;
                    lastLineNum = lineNum;
                } else if ((match = parseRef(str, i, stop))) {
                    operand.member = match.object;
                    lastLineNum = match.lastLineNum;
                    lastIndex = match.lastIndex;
                    i = match.index;
                    left = prefixed;
                } else {
                    unexpectedChar(ch, i);
                }
            } else if (str.startsWith("++", i) || str.startsWith("--", i)) {
                prefixed = operand = {  operator: str.startsWith("++", i) ? "++": "--", type: "prefix" };
                i += 2;
            } else if ((match = regexMatch(func, str, i))) {
                var f = parseFunction(str, i, n, "function");
                f = chainRef(f.object, str, stop, n, i, f.lastIndex, f.index, f.lastLineNum);
                return finalize(ctx, f, start);
            } else if ((match = regexMatch(_async, str, i))) {
                return finalize(ctx, parseAsyncFunction(str, i, n, stop, "async", ctx), start);
            } else if ((match = regexMatch(prefixOperators, str, i))) {
                return processPrefixOperator(str, i, match[0]);
            } else if ((match = regexMatch(_class, str, i))) {
                return finalize(ctx, parseClass(str, {offset : i, expression: true}, n), start);
            } else if ("0123456789tfnu".indexOf(ch = str[i]) >= 0){
                if ((match = regexMatch(litteral, str, i))) {
                    lastLineNum = lineNum;
                    lastIndex = litteral.lastIndex;
                    i = skipSpaces(str, lastIndex, n);
                    left = getLitteral(match[0]);                            
                } else {
                    if (str.startsWith("new (rest ? v : Param )(name, parseExpression(str,", i)) {
                        console.log("new (rest ? v : Param )(name, parseExpression(str,");
                    }
                    if (!(match = parseRef(str, i, str.length, stop))) {
                        unexpectedChar(ch, lineNum, getColumn(i), i);
                    }
                    left = match.object;
                    lastLineNum = match.lastLineNum;
                    lastIndex = match.lastIndex;
                    i = skipSpaces(str, match.index, n);
                }
            } else if ((match = regexMatch(oneArgArrowFunc, str, i))) {
                var af = processArrowFunc(str, n, { object: new Param(match[1]), index: skipSpaces(str, oneArgArrowFunc.lastIndex, n)}, ctx, stop, start);
                return af.object;
            } else if ((match = parseRef(str, i, str.length, stop))) {
                left = match.object;
                lastLineNum = match.lastLineNum;
                lastIndex = match.lastIndex;
                i = skipSpaces(str, match.index, n);
            }  else if (textPatternQuote && ch === textPatternQuote) {
                if (!(match = regexMatch(qspatternRe, str, i))) {
                    unexpectedChar(ch, i);
                }
                lastLineNum = lineNum;
                left = chainRef(
                        new QSPattern(match[0]), 
                        str, 
                        stop, 
                        n, 
                        start, 
                        qspatternRe.lastIndex, 
                        skipSpaces(str, qspatternRe.lastIndex, n), 
                        lastLineNum);
                lastLineNum = left.lastLineNum;
                lastIndex = left.lastIndex;
                i = skipSpaces(str, left.index, n);
                left = left.object;
            } else if (ch === '\'' || ch === '\"' || ch === '`') {
                if (!(match = regexMatch(qstring, str, i))) {
                    unexpectedChar(ch, i);
                }
                lastLineNum = lineNum;
                left = chainRef(
                        QString.getInstance(match[0]), 
                        str, 
                        stop, 
                        n, 
                        start, 
                        qstring.lastIndex, 
                        skipSpaces(str, qstring.lastIndex, n), 
                        lastLineNum);
                lastLineNum = left.lastLineNum;
                lastIndex = left.lastIndex;
                i = skipSpaces(str, left.index, n);
                left = left.object;
            } else if (ch === '{') {
                left = chainRef(parseObject(str, i, n), str, stop, n, o);
                lastLineNum = left.lastLineNum;
                lastIndex = left.lastIndex;
                i = skipSpaces(str, left.index, n);
                left = left.object;
            } else if (ch === '[') {
                left = chainRef(parseArray(str, i, n), str, stop, n, o);
                lastLineNum = left.lastLineNum;
                lastIndex = left.lastIndex;
                i = skipSpaces(str, left.index, n);
                left = left.object;
            } else if ((match = arrowFuncOrGrouping(str, i, n, _arrowOrGrp = {}))) { //arrow  function case or grouping
                if (match.arrow) {
                    var af = processArrowFunc(str, n, match, ctx, stop, start);
                    return af.object;
                } else {
                    left = chainRef(match, str, stop, n, o);
                    lastLineNum = left.lastLineNum;
                    lastIndex = left.lastIndex;
                    i = skipSpaces(str, left.index, n);
                    left = left.object;
                }
            } else if (str[i] === '(') { //grouping
                left = processGrouping(str, i, n, ctx, start);                        
                i = ctx.index;
                lastLineNum = ctx.lastLineNum;
                lastIndex = ctx.lastIndex;
            } else if (str[i] === '/') {
                left = processRegExp(str, i, n, ctx, start);                        
                i = ctx.index;
                lastLineNum = ctx.lastLineNum;
                lastIndex = ctx.lastIndex;
                //left = left.object;
            } else {
                unexpectedChar(str[i], lineNum, getColumn(i),i);
            }           
        }
        if (left) {
            var e = endExpression(str, getContext(ctx, i, lastIndex, left, lastLineNum, stop, _cmt ? _cmt.object : null, start)); 
            return e.object;
        }
        return null;
    }
    /**
     * 
     * <h3>Function calls</h3>
     * <ul>
     * <li>getContext({Object} ctx, {Number} index, {Number}  lastIndex, {Object} obj, {Number}  lastLineNum, {IComment} cmt, {Array|Function} stop, {Number}  start)</li>
     * <li>getContext({Object} ctx, {Number} index, {Object} obj, {Number}  lastLineNum, {IComment} cmt, {Array|Function} stop, {Number}  start)</li>
     * <li>getContext({Object} ctx, {Number} index, {Number}  lastIndex, {Object} obj, {Number}  lastLineNum, {Array|Function} stop, {IComment} cmt, {Number}  start)</li>
     * <li>getContext({Object} ctx, {Number} index, {Object} obj, {Number}  lastLineNum, {Array|Function} stop, {IComment} cmt, {Number}  start)</li>
     * <li>getContext({Object} ctx, {Number} index, {Number}  lastIndex, {Object} obj, {Number}  lastLineNum, {Array|Function} stop, {IComment} cmt, {Number}  start)</li>
     * <li>getContext({Object} ctx, {Number} index, {Object} obj, {Number}  lastLineNum, {Array|Function} stop, {IComment} cmt, {Number}  start)</li>
     * <li>getContext({Number} index, {Number}  lastIndex, {Object} obj, {Number}  lastLineNum, {Array|Function} stop, {IComment} cmt, {Number}  start)</li>
     * <li>getContext({Number} index, {Object} obj, {Number}  lastLineNum, {Array|Function} stop, {IComment} cmt, {Number}  start)</li>
     * <li>getContext({Number} index, {Number}  lastIndex, {Object} obj, {Number}  lastLineNum, {Array|Function} stop, {IComment} cmt, {Number}  start)</li>
     * <li>getContext({Number} index, {Object} obj, {Number}  lastLineNum, {Array|Function} stop, {IComment} cmt, {Number}  start)</li>
     * <li>getContext({Number} offset, {Array|Function} stop)</li>
     * </ul>
     * @returns {Object}
     */
    function getContext() {
        var p = 0, ctx = arguments[0];                
        if (isPlainObject(ctx))
            p++;
        else if (arguments.length === 2 && ctx !== undefined) {                    
            if (isArray(arguments[p]) || typeof arguments[p] === 'function') {
                return { offset : arguments[0], index : arguments[0], stop : arguments[1] };
            }
        }
        if (ctx === undefined) {
            ctx = {};
        }
        var _ctx = isPlainObject(ctx) ? ctx : {};
        _ctx.index = arguments[p++];
        if (isPlainObject(arguments[p])) {
            _ctx.lastIndex = _ctx.index;
            _ctx.object = arguments[p++];
        } else {
            _ctx.lastIndex = arguments[p++];
            if (typeof _ctx.lastIndex === 'undefined') {
                _ctx.lastIndex = _ctx.index;
            }
            _ctx.object = arguments[p++];
        }
        _ctx.lastLineNum = arguments[p++];
        if (arguments[p] instanceof IComment || arguments[p] === null) {
            _ctx.comment = arguments[p++];
            if (typeof arguments[p] === 'number') {
                _ctx.start = arguments[p++];
                if (isArray(arguments[p]) || typeof arguments[p] === 'function') {
                    _ctx.stop = arguments[p++];
                }
            } else if (isArray(arguments[p]) || typeof arguments[p] === 'function') {
                _ctx.stop = arguments[p++];
                if (p < arguments.length)
                    _ctx.start = arguments[p++];
            }

        }

        return _ctx;
    }

    /**
     * 
     * @param {type} str
     * @param {type} i
     * @returns {Boolean}
     */
    function isNew(str, i){
        if (typeof i !== 'number') {
            throw new Error("Incorrect number: " + i + "\nLine number: " + lineNum);
        }
        return regexMatch(regexps["new"], str, i) ? true: false; 
    }
    var CHAINERS = ['.', '[', '(', '?']
    /**
     * 
     * @param {type} obj
     * @param {type} str
     * @param {type} stop
     * @param {unsigned int} n
     * @param {unsigned int} start
     * @param {unsigned int} lastIndex
     * @param {unsigned int} index
     * @param {Array|String} chainers
     * @returns {Object}
     */
    function chainRef(obj, str, stop, n, start, lastIndex, index, lastLineNum, chainers) {
        var o, operation = null, cmt;
        if (arguments.length < 5) {
            index = obj.index;
            lastIndex = obj.lastIndex;
            lastLineNum = obj.lastLineNum;
            chainers = obj.chainers;
            o = obj.object;
        } else if (arguments.length === 5) {
            if (typeof arguments[4] === 'object') {
                index = obj.index;
                lastIndex = obj.lastIndex;
                lastLineNum = obj.lastLineNum;
                chainers = obj.chainers;
                o = obj.object;
                operation = arguments[4];                        
            } else if (typeof arguments[4] === 'undefined') {
                if (obj.hasOwnProperty('lastIndex') || obj.hasOwnProperty('index')) {
                    o = obj.object;
                    index = obj.index;
                    lastIndex = obj.lastIndex;
                    lastLineNum = obj.lastLineNum;
                } else {
                    incorrectArg(); //throw "Incorrect argument";
                }
            } else {
                o = obj;
                index = lastIndex = arguments[4];
                if (isPlainObject(chainers)) {
                    obj = chainers;
                    chainers = CHAINERS;
                } else {
                    obj = {};
                }
                obj.object = o, obj.lastIndex = lastIndex, obj.index =index ;
            }                    
        } else {
            o = obj;
            if (chainers instanceof IComment) {
                cmt = chainers;
                chainers = CHAINERS;
                obj = {};
            } else if (isPlainObject(chainers)) {
                obj = chainers;
                chainers = CHAINERS;
            } else {
                obj = {};
            }
            obj.object = o; 
            obj.lastIndex = lastIndex;
            obj.index = arguments.length > 6 ? index : lastIndex; 
            obj.start = start;
            obj.lastLineNum = lastLineNum;
        }
        if (!chainers) {
            chainers = CHAINERS;
        }

        var i = skipSpaces(str, index, n);

        var _cmt = _processComments(str, i, n);
        if (_cmt) {

            i = _cmt.index;
        }
        if (i >= n || chainers.indexOf(str[i]) < 0) {
            if (operation) {
                operation.right = o;
                o = operation;
            }
            if (_cmt) {
                if (lastLineNum === _cmt.startLineNum) {

                }
            }
            if (cmt && obj) {
                obj.comment = cmt;
            }
            return obj||{ object: o, lastIndex: lastIndex, index: index||lastIndex, start: start, lastLineNum: lastLineNum, comment : cmt};
        }
        
        //TODO : set the comment cmt
        
        if (_cmt) {
            if (lastLineNum === _cmt.startLineNum) {
                if (_cmt.object instanceof Comment) {
                    obj.object.setInlineComment(_cmt.object);
                    _cmt = null;
                } else {
                    obj.object.setInlineComment(_cmt.object.remove(0));
                }
            } 
            if (_cmt) {
                obj.object.setEndComment(_cmt.object);
            }
        }

        if ((_cmt = _processComments(str, i, n))) {

            i = _cmt.index;
        }
        var r = cascade(str, i, n, stop, obj.object, regexps.name, "invocation", obj);
        //var r = parseRef(str, i, n, stop, obj);
        if (operation) {
            operation.right = r.object;
            r.object = operation;
        }
        return r;
    }
    /**
     * 
     * @private
     * @param {type} ctx
     * @param {type} result
     * @param {type} start
     * @param {String} str
     * @param {IComment} cmt
     * @returns {Object}
     */
    function finalize(ctx, result, start, str, cmt) {
        if (arguments.length === 4) {
            if (str instanceof IComment) {
                cmt = str;
                str = null;
            }
        }
        if (typeof ctx === 'number') {
            return { index : ctx, lastIndex: ctx, object: result, comment : cmt };
        }
        if (isArray(result)) {
            if (ctx) {
                ctx.start = start;
                if (result.length >= 3) {
                    ctx.lastIndex = result[1];
                    ctx.i = ctx.index = result[2];
                } else {
                    ctx.i = ctx.lastIndex = ctx.index = result[1];
                }
                ctx.object = ctx.expression = result[0];
                if (str) {
                    ctx.match = str.substring(start, ctx.i).trim();
                }
                ctx.comment = cmt;
            }
            return result[0];
        }
        if (ctx) {
            ctx.start = start;
            ctx.lastIndex = result.lastIndex;
            ctx.i = ctx.index = result.index;
            ctx.object = result.object;
            if (typeof result.lastLineNum !== 'undefined') {
                ctx.lastLineNum = result.lastLineNum;
            }
            ctx.ender = result.ender;
            if (str) {
                ctx.match = str.substring(start, ctx.i).trim();
            }
            ctx.comment = cmt;
        }
        return result.object; 
    }

    function compareOperator(o1, o2) {
        if (isPlainObject(o1)) {
            o1 = getOperatorKey(o1);
        }
        if (isPlainObject(o2)) {
            o2 = getOperatorKey(o2);
        }
        var p1 = OPERATOR_PRECEDENCES[o1],
            p2 = OPERATOR_PRECEDENCES[o2];

        if (p1 === p2) {
            return 0;
        }
        return p1 < p2 ?  1 : -1;
    }
    /**
     * 
     * @private
     * @param {type} str
     * @param {type} i
     * @param {type} n
     * @param {type} condition
     * @param {type} ctx
     * @param {type} stop
     * @param {type} start
     * @returns {Object}
     */
    function processConditional(str, i, n, condition, ctx, stop, start) {
        _conditionals[_conditionals.length] = condition;
        var lastLineNum = lineNum, _cmt, comments = {};
        //skip conditional operator '?' and process comments                
        _cmt = processComments(str, lastLineNum, skipSpaces(str, i + 1, n), n, comments, 'outer', false);
        ctx.offset= i = _cmt.index;
        ctx.stop = [':'];
        _cmt = _cmt.comment;
        ctx.comment = null;
        var trueValue = parseExpression(str, ctx);
        if (!trueValue) {
            throw new Error("Incorrect ternary conditional expression");
        }
        _conditionals.splice(_conditionals.length - 1, 1);
        lastLineNum = lineNum;
        i = skipSpaces(str, ctx.index + 1, n);
        if ((_cmt = _processComments(str, i, n))) {
            i = _cmt.index;
            _cmt = _cmt.object;
            //TODO 

            _cmt = null;

            //TODO
        }
        var _stop;
        if (stop) { 
            _stop =  [].slice.call(stop);
            if (_stop.indexOf(':') < 0)
                _stop[_stop.length] = ':';
        } else {
            _stop = [';'];
        }

        ctx.offset = i, ctx.stop = _stop;
        var falseValue = parseExpression(str, ctx);
        if (!falseValue) {
            throw new Error("Incorrect ternary conditional expression");
        }
        if (str[ctx.index] === ':') {
            if (_conditionals.length === 0) {
                throw new Error("Unexpected character");
            } else {
                _conditionals.splice(_conditionals.length - 1, 1);
                ctx.object = new Conditional(condition, trueValue, falseValue);
                return ctx.object;
            }
        } else  {
            if (stop) { 
                if (_conditionals.length > 1) {
                    throw new Error("Unexpected character");
                }                        
            }
            ctx.stop = stop;
            ctx.object = new Conditional(condition, trueValue, falseValue);
            return endExpression(str, ctx).object; 
        }                
    }
    /**
     * 
     * @private
     * @param {type} str
     * @param {unsigned int} n
     * @param {Object} arrowFunc,
     * @param {Object} ctx,
     * @param {Array} stop
     * @param {unsigned int} start
     * @param {boolean} [strictOperatorStop]
     * @returns {Object}
     */
    function processArrowFunc(str, n, arrowFunc, ctx, stop, start, strictOperatorStop) {
        var params, returnType , obj = arrowFunc.object ;
        if (isArray(obj)) {//arguments with parenthesis
            params = obj;                    
        } else if (isArray(obj.params)) {//arguments with parenthesis
            params = obj.params; 
            returnType = obj.returnType;
        } else { //single argument without parenthesis
            params = [arrowFunc.object];
        }
        var cmt = arrowFunc.comment;
        var i = arrowFunc.index, af;
        if (i >= n) {
            unexpectedEnd(); //throw exception
        }
        if (str[i] === ':') {
            returnType = processType(str, i, n, ctx, ['{']);
        }
        if (str[i] === '{') {
            ctx.index = i;
            ctx.stop = statementEnders;
            af = parseBlock(str, ctx, n, cmt, stop, expressionAsStatement);
        } else {
            ctx.offset = ctx.index = i;
            ctx.stop = stop;            
            var lastLineNum = lineNum;
            af = parseExpression(str, ctx, strictOperatorStop);
            if (cmt) {
                af.object.setComment(cmt);
            }
            ctx.object = af;
            i = ctx.index;
            if ((cmt = _processComments(str, i, n))) {
                if (lastLineNum === lineNum) {
                    //TODO
                } else {
                    //TODO
                }
                ctx.lastIndex = cmt.lastIndex;
                ctx.index = cmt.index;
            }

        }
        ctx.object = new ArrowFunction(params, ctx.object);
        if (returnType) {
            ctx.object.setReturnType(returnType);
        }
        ctx.stop = stop;
        return ctx; 
    }

    /**
     * 
     * @private
     * @param {String} str
     * @param {unsigned int} i
     * @param {unsigned int} n
     * @param {Object} ctx
     * @param {unsigned int} start
     * @returns {Object}
     */
    function processRegExp(str, i, n, ctx, start) {
        var stop;
        if (!ctx) {
            ctx = {};
        } else {
            stop = ctx.stop||[];
        }
        var lastIndex, 
                lastLineNum = lineNum, 
                ch, 
                ofs = i + 1, 
                expr, 
                modifs = "";;
        //skip character '/'
        i++;
        while (i < n) {
            if (str.startsWith("\\/", i)) {
                i += 2;
            } else if (str[i] === '/') {
                expr = str.substring(ofs, i);
                i++;                      
                for (var k = 0; k < 3; k++) {
                    if ((ch = str[i]) === 'g') {
                        if (modifs.indexOf('g') >= 0) {
                            unexpectedChar(ch, lineNum, getColumn(i), i);
                        }
                        i++;
                        modifs += "g";
                    } else if (ch === 'i') {
                        if (modifs.indexOf('i') >= 0) {
                            unexpectedChar(ch, lineNum, getColumn(i), i);
                        }
                        i++;
                        modifs += "i";
                    } else if (ch === 'm') {
                        if (modifs.indexOf('m') >= 0) {
                            unexpectedChar(ch, lineNum, getColumn(i), i);
                        }
                        i++;
                        modifs += "m";
                    } else {
                        break;
                    }
                }
                break;
            } else {
                i++;
            }
        }
        if (typeof expr === 'undefined') {
            unexpectedEnd();
        }
        lastLineNum = lineNum;
        lastIndex = i; 
        var re = new VRegExp(expr, modifs);
        i = skipSpaces(str, i, n);
        var cmt = _processComments(str, i, n);
        if (cmt) {
            i = cmt.index;
            cmt = cmt.object;
            if (lastLineNum === cmt.startLineNum) {
                if (cmt instanceof Comment) {
                    re.setInlineComment(cmt);
                    cmt = null;
                } else {
                    re.setInlineComment(cmt.remove(0));
                }
            }
            if (cmt) {
                //TODO
            }
        }
        var match, lastLineNum, lastIndex;
        if (str[i] === '.') {
            lastIndex = i + 1;
            lastLineNum = lineNum;
            i = skipSpaces(str, i + 1, n);
            var nameRe = regexps['simple-name'];
            if ((cmt = _processComments(str, i, n))) {
                i = cmt.index;
                cmt = cmt.object;
                if (lastLineNum === cmt.startLineNum) {
                    if (cmt instanceof Comment) {
                        re.setInlineComment(cmt);
                        cmt = null;
                    } else {
                        re.setInlineComment(cmt.remove(0));
                    }
                }
                if (cmt) {
                    //TODO
                }
            }
            if (!(match = regexMatch(nameRe, str, i))) {
                unexpectedChar( '.', lineNum, getColumn(i), i );//throw new Error("Unexpected character");
            }
            var ref = new Reference(match[0], re);
            lastIndex = nameRe.lastIndex;
            lastLineNum = lineNum;
            i = skipSpaces(str, nameRe.lastIndex, n);
            return  finalize(ctx, chainRef(ref, str, stop, n, start, lastIndex, i, lastLineNum), start);

        } else if (str['[']) {
            if ((cmt = _processComments(str, i, n))) {
                i = cmt.index;
                cmt = cmt.object;
                if (lastLineNum === cmt.startLineNum) {
                    if (cmt instanceof Comment) {
                        //TODO
                        cmt = null;
                    } else {
                        //TODO
                        //re.setInlineComment(cmt.remove(0));
                    }
                }
                if (cmt) {
                    //TODO
                }
            }
        }
        return finalize(ctx, { index : i, object: re, lastLineNum: lastLineNum }, start);
    }

    /**
     * 
     * @private
     * @param {String} str
     * @param {unsigned int} i
     * @param {unsigned int} n
     * @param {Object} ctx
     * @param {unsigned int} start
     * @returns {Object}
     */
    function processGrouping(str, i, n, ctx, start) {
        var __conditionals = _conditionals;
        _conditionals = [];
        var stop, _cmt;
        if (!ctx) {
            ctx = {};
        } else {
            stop = ctx.stop||[];
        }
        var _ctx = { offset: skipSpaces(str, i + 1, str.length), stop: [')', ':']};
        var expr = parseExpression(str, _ctx);
        if (!expr) {
            return  null;                     
        }
        expr = new Grouping(expr);
        if (str[i = _ctx.index] === ':') {
            expr.setType(processType(str, i, n, _ctx, [')']));
        }
        var lastIndex = _ctx.index + 1;
        var lastLineNum = lineNum;
        _cmt= processComments(str, lastLineNum, skipSpaces(str, lastIndex, n), n, expr, 'outer', false);
        i = _cmt.index;
        _cmt = _cmt.comment;
        var g =  finalize(ctx, chainRef(expr, str, stop, n, start, lastIndex, i, lastLineNum, _cmt), start);
        _conditionals = __conditionals;
        return g;
    }
    /**
     * 
     * @private
     * @param {String} str
     * @param {unsigned int} i
     * @param {unsigned int} n
     * @param {Object} ctx
     * @param {type} left
     * @param {String} operator
     * @param {type} stop
     * @param {unsigned int} start
     * @returns {Object}
     */
    function processOperation(str, i, n, ctx, left, operator, stop, start, _cmt) {
        var o = { type: "operation", operator: operator, left: left };
        var lastLineNum = i, startLineNum;
        i = skipSpaces(str, i, n);
        if (i >= n) {
            unexpectedEnd(); //throw exception
        }
        var _ctx; 
        if (!ctx) {
            _ctx = { offset: i, stop: stop};
        } else {
            _ctx = ctx;
            ctx.offset = i;
        }
        if ((_cmt = _processComments(str, i, n))) {
            _ctx.offset = i = _cmt.index;
            startLineNum = _cmt.startLineNum;
            _cmt = _cmt.object;

            if (lastLineNum === startLineNum) {
                //TODO

                _cmt = null;
                //TODO
            }                            
        }
       var expr = parseExpression(str, _ctx);
        if (!expr) {
             throw new Error("Incorrect expression");
        }
        if (expr instanceof UnaryOperation) {
            o.right = expr;
            if (_cmt) expr.setComment(_cmt);
            o = Expression.getInstance(o);
        } else if ((expr instanceof Operation) && (compareOperator(o.operator, expr.getOperator()) > 0)) {
            o.right = expr.getLeft();
            if (_cmt) o.right.setComment(_cmt);
            expr.setLeft(Expression.getInstance(o));
            o = expr;
        } else {
            o.right = expr;
            if (_cmt) expr.setComment(_cmt);
            o = Expression.getInstance(o);
        }
        if (ctx) {
            ctx.start = start;
            ctx.match = str.substring(start, ctx.index);
        }
        return o;
    }
    /**
     * 
     * @param {String} match
     * @returns {Expression}
     */
    function getLitteral(match) {
        return match === 'false' ?  new Bool(false)
            : match === 'true' ? new Bool(true)
            : match === 'null' ? Null.NULL
            : match === 'undefined' ? Undefined.UNDEFINED
            : new Numeric(match.indexOf(".") >= 0 ? parseFloat(match) : toInteger(match));
    }
    /**
     * 
     * @param {type} str
     * @param {type} i
     * @param {type} n
     * @returns {Object}
     */
    function parseArgs(str, i, n) {
        return parseList(str, i, n, [',', ')'], 'args');
    }
    /**
     * 
     * @param {type} str
     * @param {type} i
     * @param {type} n
     * @param {type} stop
     * @param {String} listType
     * @returns {Object}
     * @todo test parseObjectDestructuring when parsing parameters
     */
    function parseList(str, i, n, stop, listType) {
        var elts = [],
                obj = { elements : elts},
                elt, opener = str[i],
                ctx,
                cmt,
                lastLineNum = lineNum, lastIndex = i;
        if (isPlainObject(stop) && typeof stop.isStop !== 'function') {
            ctx = stop;
            if (isArray(listType) || (isPlainObject(listType) && typeof listType.isStop !== 'function')) {
                stop = listType;
                listType = "";
            } else {
                stop = ctx.stop;
            }
        } else {
            ctx = { stop: stop};
        }
        //skip the opener and spaces
        i = skipSpaces(str, i + 1, n);
        cmt = processComments(str, lastLineNum, i, n, obj, 'inner', false, opener);
        i = cmt.index;
        var itemDelim = ',', listEnder = ')', destructuringOpener = '{', destructuringCloser = '}';
        if (isArray(stop)) {
            for (var k = 0, len = stop.length; k < len; k++) {
                if (")]}>".indexOf(stop[k]) >= 0) {
                    listEnder = stop[k];
                } else if (",;".indexOf(stop[k]) >= 0) {
                    itemDelim = stop[k];
                }
            }
        }
        if (str[i] === itemDelim) {
            unexpectedChar(str[i], lineNum, getColumn(i), i);
        }

        lastLineNum = lineNum;
        while (i <n) {                    
            if (str[i] === listEnder) { // For example : ']', ')' for arguments or parameters
                if (elt) {
                    elts[elts.length] = elt;
                }
                lastLineNum = lineNum;
                lastIndex = i + 1;
                cmt = processComments(str, lineNum, skipSpaces(str, lastIndex, n), n, obj, 'outer', false);
                return  {
                    object: obj,
                    index: cmt.index,
                    lastIndex: lastIndex,
                    lastLineNum: lastLineNum,
                    comment: cmt
                };
            } else if (str[i] === itemDelim) { // for example ','
                if (!elt) {                            
                    unexpectedChar(str[i], lineNum, getColumn(i), i);
                }
                elts[elts.length] = elt;
                lastIndex = i + 1;
                cmt = processComments(str, lineNum, skipSpaces(str, lastIndex, n), n, elt, 'outer', false, itemDelim);
                i = cmt.index;
                elt = null;
            } else if (str[i] === destructuringOpener && listType === 'params') {
                elt = parseObjectDestructuring(str, i, n);
                elts[elts.length] = elt.object;
                i = elt.index;
            } else {
                ctx.offset = i;
                elt = listType === 'params' ? parseParam(str, ctx) 
                    : parseExpression(str, ctx);
                if (!elt) {                            
                    unexpectedChar(str[i], lineNum, getColumn(i), i);
                }
                if (cmt instanceof IComment) {
                    elt.setComment(cmt);
                } else if (cmt.comment) {
                    if (cmt.inline) {
                        elt.setInlineComment(cmt.comment);
                    } else {
                        elt.setComment(cmt.comment);
                    }
                }
                i = ctx.index;
                cmt = ctx.comment;
            }
        }
        unexpectedEnd();
    }
    /**
     * 
     * @example
     * <ul>
     * <li>Example of destructuring parameter: <code>'parseObjectDestructuring(str, i, n)'</code></li>
     * <li>Example of function:
     * <p><code>function dessinGrapheES2015({size = 'big', coords = { x: 0, y: 0 }, radius = 25} = {})<br/> 
     *  {<br/>
     *  &nbsp;&nbsp;console.log(size, coords, radius);<br/> 
     *  &nbsp;// on dessine le graphe<br/> 
     *  }<br/>
     * <br/>
     *  dessinGrapheES2015({<br/>
     *  &nbsp;&nbsp;coords: { x: 18, y: 30 },<br/> 
     *  &nbsp;&nbsp;radius: 30<br/> 
     *  });</code></p></li>
     *  </ul>
     * @param {type} str
     * @param {type} i
     * @param {type} n
     * @param {String|Boolean} dType  Destructuring type
     * <p>Possible values: </p>
     * <ul>
     * <li>'param': for single options (object)  function or class parameter destructuring</li>
     * <li>'of': for the 'forof' loop variable destructuring</li>
     * <li>'', 'assign', undefined or null: for destructuring assignment</li>
     * </ul>
     * @param {Object} ctx
     * @param {Boolean} strict  Each parameter/variable entry must have a default value?
     * @returns {Object}
     */
    function parseObjectDestructuring(str, i, n, dType, ctx, strict) {
        if (isPlainObject(dType)) {
            ctx = dType;
            dType = false;
        }
        var cstop, optionalChaining = false;
        if (ctx) {
            cstop = ctx.stop;
            ctx.stop = [',', '}'];
        } else {
            ctx = { stop: [',', '}'] };
        }
        
        var stack = {
            elts : [],
            index: -1,                    
            add: function(e) {
                this.elts[++this.index] = e;
            },
            remove: function() {
                var e= this.elts[this.index];
                this.elts.splice(this.index--, 1);
                return e;
            },
            size: function() {
                return this.elts.length;
            }
        };
        
        function isObjDefaultValue(defVal) {
            return defVal instanceof VObject 
                    || defVal instanceof RefChain 
                    || defVal instanceof BaseIndex 
                    || defVal instanceof Instantiation 
                    || defVal instanceof Invocation
                    || defVal instanceof VArray 
                    || defVal instanceof VString || defVal instanceof QString;
        }
        
        function end() {
            if (rest) {
                variables.put(defaultValue ? new ODRest(name, defaultValue) : new ODRest(name));
            } else if (sub) {
                variables.set(name, defaultValue ? defaultValue: Value.NO_VALUE, sub);
            } else {
                variables.set(name, defaultValue ? defaultValue: Value.NO_VALUE, alias);
            }
            if (dType === 'of') {
                if (!str.startsWith("of", i) || " \t\n\r\v\b\0".indexOf(str[i + 2]) < 0) {
                    //throw newError("Expected keyword 'of'");
                    expectedKeyword('of', str[i], lineNum, getColumn(i), i);
                }
                if (cstop) {
                    ctx.stop = cstop;
                }
                getContext(ctx, i, lastIndex, variables, lastLineNum, null);
                ctx["of"] = true;
                ctx.beforeOfComment = cmt ? cmt : null; //before 'of' comments
                return ctx;
            } else if (str[i] !== '=') {                
                if ((dType === 'param' && (str[i] === ')')) || ((dType === 'ar' || dType === 'arr' || dType === 'sub') && ",])".indexOf(str[i]) >= 0)) {
                    return { lastIndex: lastIndex, index : i, object : variables };
                }
                //throw newError("Expected character '='");
                expectedChar('=', str[i], lineNum, getColumn(i), i); 
            }
            lastIndex = i + 1;
            lastLineNum = lineNum;
            i = skipSpaces(str, i + 1, n);
            if ((cmt = _processComments(str,i, n))) {
                i = cmt.index;
                //TODO
            }
            if (dType) {
                if (str[i] !== '{') {
                    //throw newError("Expected character");
                    expectedChar('{', str[i], lineNum, getColumn(i), i); 
                }
                ctx.offset = i;
                ctx.stop = [')', ']', ','];
                var defVal = parseExpression(str, ctx);
                if (!isObjDefaultValue(defVal)) {
                    throw new Error("Incorrect default value");
                }
                ctx.object = new (dType === 'param' ? DParam : VarsElt)(variables, defVal);
                if (cstop) {
                    ctx.stop = cstop;
                }                            
                return ctx;
            } else {
                ctx.offset =  i; ctx.stop =  [ ',', ')', '}', ';', unclosedStatementEnd];
                ctx.object = new ODAssign(variables, parseExpression(str, ctx));
                if (cstop) {
                    ctx.stop =  cstop;
                }
                return ctx;
            }
        }

        //skip character '{' and spaces
        i = skipSpaces(str, i + 1, n);
        var ch, defaultValue, lastIndex, lastLineNum,
                cmt, sub,
                variables = new ODVariables(), 
                nameRe = regexps['simple-name'], name, alias, rest = false; 
        while (i < n) {
            ch = str[i];
            if (nameStart(str, i)) {
                if (defaultValue || name) {
                    //throw newError("Unexpected character");
                    unexpectedChar(ch, lineNum, getColumn(i), i); 
                }
                name = regexMatch(nameRe, str, i)[0];
                lastIndex = i + 1;
                lastLineNum = lineNum;
                i = skipSpaces(str, nameRe.lastIndex, n);
                if ((cmt = _processComments(str,i, n))) {
                    i = cmt.index;
                    //TODO
                }
            } else if (ch === ':') {
                if (defaultValue || !name) {
                     //throw newError("Unexpected character");
                    unexpectedChar(ch, lineNum, getColumn(i), i); 
                }
                lastIndex = i + 1;
                lastLineNum = lineNum;
                i = skipSpaces(str, i + 1, n);
                if ((cmt = _processComments(str,i, n))) {
                    i = cmt.index;
                    //TODO
                }
                if (optionalChaining) {
                    if (str[i] !== '{') {
                        //throw newError("Unexpected character");
                        unexpectedChar(ch, lineNum, getColumn(i), i); 
                    }
                } else if (str[i] !== '{' && str[i] !== '[') {
                    alias = regexMatch(nameRe, str, i)[0];
                    lastIndex = i + 1;
                    lastLineNum = lineNum;
                    i = skipSpaces(str, nameRe.lastIndex, n);
                    if ((cmt = _processComments(str,i, n))) {
                        i = cmt.index;
                        //TODO
                    }
                }
            } else if (ch === '=') {
                if (defaultValue || !name || optionalChaining) {
                    //throw newError("Unexpected character");
                    unexpectedChar(ch, lineNum, getColumn(i), i); 
                }
                lastIndex = i + 1;
                lastLineNum = lineNum;
                i = skipSpaces(str, i + 1, n);
                if ((cmt = _processComments(str,i, n))) {
                    i = cmt.index;
                    //TODO
                }
                ctx.offset = i;
                defaultValue = parseExpression(str, ctx);
                i = ctx.index;                        
            } else if (ch === ',') {
                if (!name || (strict && !defaultValue)) {
                    //throw newError("Unexpected character");
                    unexpectedChar(ch, lineNum, getColumn(i), i); 
                }
                if (rest) {
                    //throw newError("Unexpected character");
                    unexpectedChar(ch, lineNum, getColumn(i), i, "Unexpected character after rest/remian element"); 
                }
                if (sub) {
                    variables.set(name, defaultValue ? defaultValue: Value.NO_VALUE, sub);
                    sub = null;
                } else {
                    variables.set(name, defaultValue ? defaultValue: Value.NO_VALUE, alias);
                    alias = "";
                }
                defaultValue = null;
                name = "";
                lastIndex = i + 1;
                lastLineNum = lineNum;
                i = skipSpaces(str, lastIndex, n);
                if ((cmt = _processComments(str,i, n))) {
                    i = cmt.index;
                    //TODO
                }
            } else if (ch === '}') {
                if (!defaultValue && !name) {
                    //throw newError("Unexpected character");
                    unexpectedChar(ch, lineNum, getColumn(i), i); 
                }
                
                if (stack.size()) {
                    if (rest) {
                        variables.put(defaultValue ? new ODRest(name, defaultValue) : new ODRest(name));
                    } else if (sub) {
                        variables.set(name, defaultValue ? defaultValue: Value.NO_VALUE, sub);
                        sub = null;
                    } else {
                        variables.set(name, defaultValue ? defaultValue: Value.NO_VALUE, alias);
                        alias = "";
                    }
                    defaultValue = null;
                    name = "";
                    for (;;) {
                        var el = stack.remove();
                        name = el.name;
                        sub = variables;
                        variables = el.variables;
                        lastIndex = i + 1;
                        lastLineNum = lineNum;
                        i = skipSpaces(str, lastIndex, n);
                        if ((cmt = _processComments(str, i, n))) {                            
                            i = cmt.index;
                            //TODO
                        }
                        ch = str[i];
                        if (ch === '}') {
                            if (stack.size() === 0) {
                                lastIndex = i + 1;
                                lastLineNum = lineNum;
                                i = skipSpaces(str, lastIndex, n);
                                if ((cmt = _processComments(str, i, n))) {                            
                                    i = cmt.index;
                                    //TODO
                                }
                                if (str[i] === '}') {
                                    unexpectedChar(ch, lineNum, getColumn(i), i);
                                }
                                return end();
                            }

                            variables.set(name, defaultValue ? defaultValue: Value.NO_VALUE, sub);
                            name = "";
                            defaultValue = null;
                        } else {
                            break;
                        }                        
                    }
                } else {
                    lastIndex = i + 1;
                    lastLineNum = lineNum;
                    i = skipSpaces(str, lastIndex, n);
                    if ((cmt = _processComments(str, i, n))) {                            
                        i = cmt.index;
                        //TODO
                    }
                    return end();
                }
                
                
            } else if (ch === '{') {
                if (!name || alias) {
                    unexpectedChar(ch, lineNum, getColumn(i), i);
                }                
                stack.add({ variables: variables, name:name});
                variables = new ODVariables();
                if (optionalChaining) {
                    variables.setOptionalChaining(true);
                    optionalChaining = false;
                }                
                name = "";
                lastIndex = i + 1;
                lastLineNum = lineNum;
                i = skipSpaces(str, lastIndex, n);
                if ((cmt = _processComments(str, i, n))) {                            
                    i = cmt.index;
                    //TODO
                }
            } else if (ch === '[') {
                var arr = parseArrayDestructuring(str, i, n, "ar", ctx);
                i = arr.index;
                sub = arr.object;
            } else if (ch === '?' && nameStart(str, i + 1)) {
                i++;
                if (defaultValue || name) {
                    //throw newError("Unexpected character");
                    unexpectedChar(ch, lineNum, getColumn(i), i); 
                }
                name = regexMatch(nameRe, str, i)[0];
                optionalChaining = true;
                lastIndex = i + 1;
                lastLineNum = lineNum;
                i = skipSpaces(str, nameRe.lastIndex, n);
                if ((cmt = _processComments(str,i, n))) {
                    i = cmt.index;
                    //TODO
                }
            } else if (str.startsWith("...", i)) {
                if (defaultValue || name) {
                    unexpectedChar(ch, lineNum, getColumn(i), i); //throw newError("Unexpected character");
                }
                i += 3; 
                if ((name = regexMatch(nameRe, str, i))) {
                    name = name[0];
                    rest = true;
                    i = skipSpaces(str, nameRe.lastIndex, n);
                    //TODO: process comments
                } else {
                    unexpectedChar(ch, lineNum, getColumn(i), i); //throw newError("Unexpected character");
                }
            } else {
                //throw newError("Unexpected character");
                unexpectedChar(ch, lineNum, getColumn(i), i); 
            }
        }
    } 
    /**
     * 
     * @example
     * <ul>
     * <li>Example of destructuring parameter: <code>'parseObjectDestructuring(str, i, n)'</code></li>
     * <li>Example of function:
     * <p><code>function dessinGrapheES2015({size = 'big', coords = { x: 0, y: 0 }, radius = 25} = {})<br/> 
     *  {<br/>
     *  &nbsp;&nbsp;console.log(size, coords, radius);<br/> 
     *  &nbsp;// on dessine le graphe<br/> 
     *  }<br/>
     * <br/>
     *  dessinGrapheES2015({<br/>
     *  &nbsp;&nbsp;coords: { x: 18, y: 30 },<br/> 
     *  &nbsp;&nbsp;radius: 30<br/> 
     *  });</code></p></li>
     *  </ul>
     * @param {type} str
     * @param {type} i
     * @param {type} n
     * @param {String|Boolean} dType  Destructuring type
     * <p>Possible values: </p>
     * <ul>
     * <li>'param': for single options (object)  function or class parameter destructuring</li>
     * <li>'of': for the 'forof' loop variable destructuring</li>
     * <li>'', 'assign', undefined or null: for destructuring assignment</li>
     * </ul>
     * @param {Object} ctx
     * @param {Boolean} strict  Each parameter/variable entry must have a default value?
     * @returns {Object}
     */
    function processObject(str, i, n, dType, ctx, strict) {
        function processCall() {
            cstop = ctx.stop;
            params = parseParams(str, i, n, ctx);
            i = params.index;
            var lastLineNum = params.lastLineNum;
            params = params.object;
            returnType = null;
            if (str[i] === ':') {
                returnType = processType(str, i, n, ctx, ['{']);
                i = ctx.index;        
            }
            if (str[i] !== '{') {
                throw new Error("Expected character '{', found '" + str[i] + "'"
                        + " at line " + lineNum + ", column " + (getColumn(i)) + " and index " + i);
            }
            ctx = parseBlock(str, i, n, _cmt, expressionAsStatement, ctx);
            _cmt = ctx.comment;
            i = ctx.index;
            body = ctx.object;
        }
        function toDOptions() {
            variables =  new ODVariables();
            var e;
            for (var i = 0, n = entries.length; i < n; i++ ) {
                e = entries[i];
                variables.set(e.name, e.defaultValue ? e.defaultValue : Value.NO_VALUE, e.alias||"" );
            }
            entries = null;
        }
        
        function toObject(_entries) {
            if (!_entries) {
                _entries = entries;
            }
            obj = new VObject();
            var e;
            for (var i = 0, n = _entries.length; i < n; i++ ) {
                e = _entries[i];
                if (e.type === 'name') {
                    _entries[i] = new AutoRefEntry(e);
                } else if (e.alias) {
                    e.value = new Reference(e.alias);
                    _entries[i] = new Entry(e);                    
                } else if (e.entries) {
                    var _obj = obj;
                    toObject(e.entries);
                    e.value = obj;
                    obj = _obj;
                }
            }
            obj.setEntries(_entries);
        }
        
        function addEntry() {   
            if (entry instanceof ODRest) {
                if (vobject) {
                    throw new Error("");
                }
                if (!destructuring) {
                    toDOptions();
                    destructuring = true;
                }
                variables.put(entry);
            } else if (entry instanceof EMethod || entry instanceof EAccessor) {
                if (destructuring) {
                    throw new Error("");
                }
                if (!vobject) {
                    toObject();
                    vobject = true;
                }
                entries[entries.length] = entry;
            } else if (destructuring && entry) {
                variables.put(entry);
            } else if (vobject) {
                if (defVal) {
                    throw new Error("");
                }
                if (entry) {
                    entries[entries.length] = entry;
                } else if (val) {
                    entries[entries.length] = new Entry(name);
                } else {
                    entries[entries.length] = new AutoRefEntry(name);
                }
            } else if (state === DEFAULT_VALUE || alias) {
                if (vobject) {
                    throw new Error("");
                }
                if (!destructuring) {
                    destructuring = true;
                    toDOptions();
                }
                if (entry) {
                    variables.put(entry);
                } else {
                    variables.set(name, defVal, alias );
                }
            } else if (val) {
                if (destructuring) {
                    throw new Error("");
                }
                if (!vobject) {
                    toObject();
                }
                entries[entries.length] = new Entry(name, val);
            } else if (alias) {
                entries[entries.length] = { name: name, alias: alias};
            } else {
                entries[entries.length] = { type: 'name', name: name};
            }
            name = "";
            defVal = null;
            alias = "";
            val = null;
            entry = null;
        }
        
        function processColon() {
            if (state !== KEY) {
                 //throw newError("Unexpected character");
                unexpectedChar(ch, lineNum, getColumn(i), i); 
            }
            lastIndex = i + 1;
            lastLineNum = lineNum;
            i = skipSpaces(str, i + 1, n);
            if ((cmt = _processComments(str,i, n))) {
                i = cmt.index;
                cmt = cmt.object||cmt.comment;
            }
            if (vobject) {
                ctx.offset = i;
                ctx.stop = [',', '}'];
                ctx.comment = null;_=k$io
                val = parseExpression(str, ctx);
                state = VALUE;
            } else if (destructuring) {
                if (ch === '{') {
                    stack.add({ variables: variables, name: name});
                    variables = new ODVariables();
                    state = 0;
                    name = null;
                } else if (ch === '[') {
                    var res = parseArrayDestructuring(str, i, n, "", ctx);
                    i = res.index;
                    variables.set(name, res.object);
                    state = ARRAY_DESTRUCT;
                } else if ((alias = regexMatch(nameRe, str, i))) {
                    alias = alias[0];
                    lastIndex = nameRe.lastIndex;
                    lastLineNum = lineNum;
                    i = skipSpaces(str, nameRe.lastIndex, n);
                    if ((cmt = _processComments(str,i, n))) {
                    i = cmt.index;
                        //TODO
                    }
                    state = ALIAS;
                }
            } else if ((alias = regexMatch(nameRe, str, i))) {
                alias = alias[0];
                lastIndex = nameRe.lastIndex;
                lastLineNum = lineNum;
                i = skipSpaces(str, nameRe.lastIndex, n);
                if ((cmt = _processComments(str,i, n))) {
                i = cmt.index;
                    //TODO
                }
                state = ALIAS;
            } else if (ch === '{') {
                if (destructuring) {
                    stack.add({ variables: variables, name: name});
                    variables = new ODVariables();
                    open++;
                    state = 0;
                    name = "";
                } else if (vobject) {
                    ctx.comment =  null;
                    ctx.offset = i;
                    ctx.stop = [',', '}'];
                    var expr = parseExpression(str, ctx);
                    if (cmt) {
                        expr.setComment(cmt);
                    }
                    i = ctx.index;
                    cmt = ctx.comment;
                } else {
                    stack.add({ entries: entries, name: name});
                    entries = [];
                    open++;
                    state = 0;
                    name = "";
                }
            } else if (ch === '[') {
                if (destructuring) {
                    var res = parseArrayDestructuring(str, i, n, "ar", ctx);
                    i = res.index;
                    entry = { name: name, object: res.object };
                } else if (vobject) {
                    ctx.comment =  null;
                    ctx.offset = i;
                    ctx.stop = [',', '}'];
                    val = parseExpression(str, ctx);
                    i = ctx.index;
                    cmt = ctx.comment;
                } else {
                    var arr = processArray(str, i, n, "", ctx);
                    i = arr.index;
                    arr = arr.object;
                    if (arr instanceof ADVariables) {
                        if (vobject) {
                            throw new Error("");
                        }
                        if (!destructuring) {
                            toDOptions();
                        }                        
                    } else if (arr instanceof VObject) {
                        if (destructuring) {
                            throw new Error("");
                        }
                        if (!vobject) {
                            toObject();
                        }
                    }
                    entry = {name :  name, object : arr };
                }
            } else {
                if (destructuring) {
                    //throw newError("Unexpected character");
                    unexpectedChar(ch, lineNum, getColumn(i), i); 
                }
                if (!vobject) {
                    vobject = true;
                    toObect();
                }
                val = parseExpression(str, ctx);
                state = VALUE;
            }
        }
        
        function  processSquareBracket() {
            if (state === COMMA || state === 0) {                    
                if (!(match = regexMatch(CName.SQUARE_REGEXP, str, i))) {
                    throw new Error("Expected computed object property name");
                }
                lastIndex = CName.SQUARE_REGEXP.lastIndex;
                lastLineNum = lineNum;
                name = match[0];  

                cmt = processComments(str, lastLineNum, i, n, entry, 'afterName', false);
                i = cmt.index;
                if (str[i] === '(') {
                    processCall();
                    if (destructuring) {
                        unexpectedChar(ch, lineNum, getColumn(i), i);
                    }
                    if (!vobject) {
                        vobject = true;
                        toObject();
                    }
                    entry = new EMethod(name, params, body);
                    if (returnType) {
                        entry.setReturnType(returnType);
                    }
                    state = METHOD;
                    cmt = ctx.comment;
                    if (str[i] !== ',') {
                        unexpectedChar(ch, lineNum, getColumn(i), i);
                    }
                } else {
                    entry = { name: name};
                    state = KEY;
                }
            } else {
                unexpectedChar(ch, lineNum, getColumn(i), i);
            }
        }
        
        function processRest() {
            if (vobject) {
                throw new Error("");
            }
            if (!destructuring) {
                toDOptions();
                destructuring = true;
            }
            i += 3;
            if (!(name = regexMatch(nameRe, str, i))) {
                throw new Error("Expected name");
            }
            name = name[0];
            entry = new ODRest(name);
            if (cmt) {
                entry.setComment(cmt);
            }
            lastIndex = i + 1;
            lastLineNum = lineNum;
            i = skipSpaces(str, nameRe.lastIndex, n);
            if ((cmt = _processComments(str,i, n))) {
                i = cmt.index;
                //TODO
            }
            if (str[i] !== '=') {
                ctx.offset = i;
                var comments = {};
                cmt = processComments(str, lastLineNum, i, n, comments, '', false);
                i = cmt.index;
                defVal = parseExpression(str, ctx);
                defVal.setComments(comments);
                if (!(defVal instanceof VObject)) {
                    throw new Error("Object expected");
                }
            }
            if (str[i] !== '}') {
                throw new Error("Expected character '}");
            }
            state = REST;
        }
        
        function end() {             
            lastIndex = i + 1;
            lastLineNum = lineNum;
            i = skipSpaces(str, lastIndex, n);
            if ((cmt = _processComments(str, i, n))) {                            
                i = cmt.index;
                //TODO
            }
            if (dType === 'of') {
                if (!str.startsWith("of", i) || " \t\n\r\v\b\0".indexOf(str[i + 2]) < 0) {
                    //throw new Error("Expected keyword 'of'");
                    expectedKeyword('of', str[i], lineNum, getColumn(i), i);
                }
                if (cstop) {
                    ctx.stop = cstop;
                }
                getContext(ctx, i, lastIndex, variables, lastLineNum, null);
                ctx.beforeOfComment = cmt ? cmt : null; //before 'of' comments
                return ctx;
            } else if (dType === 'ar') {
                if (cstop) {
                    ctx.stop = cstop;
                }
                getContext(ctx, i, lastIndex, variables, lastLineNum, null);
                ctx.comment = cmt ? cmt : null; 
                return ctx;
            } else if (str[i] !== '=') {
                if (dType === 'param') {
                    if (str[i] !== ')') {
                        unexpectedChar(str[i], lineNum, getColumn(i), i);
                    }
                    return { lastIndex: lastIndex, index : i, object : variables };
                } else if (str[i] === ')') {
                    if (destructuring) {
                        unexpectedChar(str[i], lineNum, getColumn(i), i);
                    }
                    if (!vobject) {
                        toObject();
                    }
                } else if (!vobject) {
                    toObject();                    
                }
                //TODO : chain obj
                return obj;
            }
            lastIndex = i + 1;
            lastLineNum = lineNum;
            i = skipSpaces(str, i + 1, n);
            variables.set(name, defVal, alias);
            if ((cmt = _processComments(str,i, n))) {
                i = cmt.index;
                //TODO
            }
            if (dType === 'param') {
                if (str[i] !== '{') {
                    //throw newError("Expected character");
                    expectedChar('{', str[i], lineNum, getColumn(i), i); 
                }
                lastIndex = i + 1;
                lastLineNum = lineNum;
                //skip character '{' and spaces
                i = skipSpaces(str, i + 1, n);
                if ((cmt = _processComments(str,i, n))) {
                    i = cmt.index;
                    //TODO
                }
                if (str[i] !== '}') {
                    //throw newError("Expected character");
                    expectedChar('}', str[i], lineNum, getColumn(i), i); 
                }
                lastIndex = i + 1;
                lastLineNum = lineNum;
                //skip character '}' and spaces : can change the line number
                i = skipSpaces(str, lastIndex, n);
                cmt = processComments(str, lastLineNum, i, n, variables, 'outer', false);
                if (cstop) {
                    ctx.stop = cstop;
                }
                ctx.assign = true;                            
                return getContext(ctx, cmt.index, lastIndex, variables, lastLineNum,cmt.comment);
            } else {
                ctx.offset =  i; ctx.stop =  [ ',', ')', '}', ';', unclosedStatementEnd];
                ctx.object = new ODAssign(variables, parseExpression(str, ctx));
                if (cstop) {
                    ctx.stop =  cstop;
                }
                return ctx;
            }
        }
        
        function processKey() {
            
            if (nameStart(str, i)) {
                if (defVal || name) {
                    //throw newError("Unexpected character");
                    unexpectedChar(ch, lineNum, getColumn(i), i); 
                }
                
                name = regexMatch(nameRe, str, i)[0];
                lastIndex = i + 1;
                lastLineNum = lineNum;
                i = skipSpaces(str, nameRe.lastIndex, n);
                if ((cmt = _processComments(str,i, n))) {
                    i = cmt.index;
                    //TODO
                }
                if (name === 'set' || name === 'get') {
                    var nameRe = regexps['simple-name'];
                    if (!(match = regexMatch(nameRe, str, i))) {                    
                       throw new Error("Expected " 
                                + (name === 'set' ? 'setter' : 'getter') 
                                + " property name. Found character '"+ str[i] + "'"
                                + " at line " + lineNum + ", column " + (getColumn(i)) + " and index " + i);
                    }
                    if (_cmt) {
                        entry.setComment(_cmt);
                    }
                    lastLineNum = lineNum;
                    i = skipSpaces(str, nameRe.lastIndex, n);
                    if (i >= n) {
                        unexpectedEnd();
                    }
                    comments = {};
                    _cmt = processComments(str, lastLineNum, i, n, comments, '', true);
                    i = _cmt.index;
                    _cmt = _cmt.comment;
                    processCall();
                    entry = new (name === 'get' ? EGetter : ESetter)(match[0], params, body);
                    if (returnType) {
                        entry.setReturnType(returnType);
                    }
                    val = undefined;
                    state = ACCESSOR;
                }
                else if (str[i] === '(') {
                    if (destructuring) {
                         //throw newError("Unexpected character");
                        unexpectedChar(str[i], lineNum, getColumn(i), i); 
                    }
                    processCall();
                    if (!vobject) {
                        vobject = true;
                        toObject();
                    }
                    entry = new EMethod(match[0], params, body);
                    if (returnType) {
                        entry.setReturnType(returnType);
                    }
                    state = METHOD;
                } else {
                    state = KEY;
                }
            } else if (str.startsWith('...', i)) {
                processRest();
            } else {
                unexpectedChar(str[i], lineNum, getColumn(i), i);
            }
        }
        
        var stack = {
                elts : [],
                index: -1,                    
                add: function(e) {
                    this.elts[++this.index] = e;
                },
                remove: function() {
                    var e= this.elts[this.index];
                    this.elts.splice(this.index--, 1);
                    return e;
                },
                size: function() {
                    return this.elts.length;
                }
            }, 
            ctx = {},
            _cmt,
            cstop,
            params,
            returnType,
            body;
        if (isPlainObject(dType)) {
            ctx = dType;
            dType = false;
        }
        var cstop, state = 0, 
            KEY = 1, COLON = 2, COMMA = 3, DEFAULT_VALUE = 4, 
            ACCESSOR = 5, METHOD = 6, VALUE = 7,ALIAS = 8,
            ARRAY_DESTRUCT = 9, REST = 10;
        if (ctx) {
            cstop = ctx.stop;
            ctx.stop = [',', '}'];
        } else {
            ctx = { stop: [',', '}'] };
        }
        var open = 1, entries,val, destructuring, vobject = false, entry, comments;

        //skip character '{' and spaces
        i = skipSpaces(str, i + 1, n);
        var ch, defVal, lastIndex, lastLineNum,
                cmt, match,
                variables, obj,
                nameRe = regexps['simple-name'], name, alias; 
        
        if (dType === 'of' || dType === 'param') {
            destructuring = true;
            variables = new ODVariables();
        } else {
            entries = [];
            destructuring = false;
        }
        while (i < n) {
            ch = str[i];
            if (state === 0 || state === COMMA) {
                processKey();
            } else if (ch === ':') {
                processColon();           
            } else if (ch === '=') {
                if (defVal || !name) {
                    //throw newError("Unexpected character");
                    unexpectedChar(ch, lineNum, getColumn(i), i); 
                }
                lastIndex = i + 1;
                lastLineNum = lineNum;
                i = skipSpaces(str, i + 1, n);
                if ((cmt = _processComments(str,i, n))) {
                    i = cmt.index;
                    //TODO
                }
                ctx.offset = i;
                if (entry) {
                    entry.defaultValue = parseExpression(str, ctx);
                } else {
                    defVal = parseExpression(str, ctx);
                }
                
                i = ctx.index;    
                state = DEFAULT_VALUE;
            } else if (ch === ',') {
                if (!name || (strict && !defVal)) {
                    //throw newError("Unexpected character");
                    unexpectedChar(ch, lineNum, getColumn(i), i); 
                }
                addEntry();
                lastIndex = i + 1;
                lastLineNum = lineNum;
                i = skipSpaces(str, lastIndex, n);
                if ((cmt = _processComments(str,i, n))) {
                    i = cmt.index;
                    //TODO
                }
                state = COMMA;
            } else if (ch === '}') {
                if (name || (strict && !defVal)) {
                    addEntry();
                } else {
                    unexpectedChar(ch, lineNum, getColumn(i), i); 
                }
                lastIndex = i + 1;
                lastLineNum = lineNum;
                i = skipSpaces(str, lastIndex, n);
                if ((cmt = _processComments(str,i, n))) {
                    i = cmt.index;
                    //TODO
                }
                var e;
                do {
                    if (stack.index < 0) {
                        return end();
                    }
                    e = stack.remove();
                    if (e.variables) {
                        entry = { name: e.name, object: variables };
                        if (e.defaultValue) {
                            entry.defaultValue = e.defaultValue;
                        }
                        variables = e.variables;
                        variables.put(e);
                    } else {
                        entry = { name: e.name, object: entries };
                        entries = e.entries;
                        entries[entries.length] = entry;
                    }
                    lastIndex = i + 1;
                    lastLineNum = lineNum;
                    i = skipSpaces(str, lastIndex, n);
                    if ((cmt = _processComments(str,i, n))) {
                        i = cmt.index;
                        //TODO
                    }
                } while ((ch = str[i]) === '}');
                entry = null;
                name = "";
            } else if (ch === '{') {
                if (state === COLON) {
                    
                } else {
                    unexpectedChar(ch, lineNum, getColumn(i), i);
                }
            } else if (ch === '[') {
                processSquareBracket();
            } else if (ch === '"' || ch === "'") {
                if (state === COMMA || state === 0) {
                    if (!(match = regexMatch(regexps.qstring, str, i))) {
                        throw new Error("Unclosed quoted string");
                    }
                    //TODO
                } else {
                    unexpectedChar(ch, lineNum, getColumn(i), i);
                }
            } else {
                //throw newError("Unexpected character");
                unexpectedChar(ch, lineNum, getColumn(i), i); 
            }
        }
    }
    /**
     * 
     * @private
     * @param {String} str
     * @param {Number} i the offset index
     * @param {Number} n  The length of the string or the end index
     * @param {Boolean|String|Number} of
     * @param {Object} ctx
     * @returns {Object}
     */
    function processArray(str, i, n, of, ctx) {
        var destructuring, arr, arrObj,stop = [',', ']'];
        if (str[i] === '?') { //operator (symbol): '?['
            i++;
            arr = arrObj = new ADVariables();
            arr.setOptionalChaining(destructuring = true);
        } else { //operator (symbol): '['
            destructuring = false;
            arr = [],
            arrObj = { array: arr };
        }
        if (of instanceof String || of instanceof Boolean || of instanceof Number) {
            of  = of.valueOf();
        }
        
        if (ctx instanceof String || ctx instanceof Boolean || ctx instanceof Number) {
            ctx  = ctx.valueOf();
        }
        
        if (isPlainObject(of)) {
            var temp = ctx;
            ctx = of;
            of = temp === true || temp === 1 || (typeof temp === 'string' && (temp.toLowerCase() === "of" || toBool(temp))) ? "of" : "";
        }
        if (isPlainObject(ctx)) {
            ctx.stop = stop;
        } else {
            ctx = { stop: stop };
        }
        var offset = i;
        
        var ch, defaultValue,
            nameRe = regexps['simple-name'], name,
            lastLineNum = lineNum,
            lastIndex,
            _cmt; 
        var elt = {} ;
        //skip character '[' and spaces
        _cmt = processComments(str, lastLineNum, skipSpaces(str, i + 1, n), n, elt, '', false);
        i = _cmt.index;
        
        var stack = of ? null : {
            elts : [],
            index: -1,                    
            add: function(e) {
                this.elts[++this.index] = e;
            },
            remove: function() {
                var e= this.elts[this.index];
                this.elts.splice(this.index--, 1);
                return e;
            },
            size: function() {
                return this.elts.length;
            }
        };
        function add() {
            if (!name) {
                if (varray && !(elt instanceof Expression)) {
                    unexpectedChar(str[i], lineNum, getColumn(i), i);
                }
                if (!(arr instanceof ADVariables)) {
                    arr = arrObj = toDArray(arrObj);
                    destructuring = true;
                }
                arr.add(elt = new SkipableElt(elt));
            } else if (arr instanceof VArray) {
                arr.add(elt);
            } else if (destructuring) {
                arr.add(elt = DArrayElt.getInstance(elt));
            } else {
                arr[arr.length] = elt;
            }
            name = "";
            defaultValue = undefined;
        }
        function toDArray(arrObj) {
            var arr = arrObj.array, n = arr.length,e;
            for (var i = 0; i < n; i++) {
                e = arr[i];
                if (isPlainObject(e) && isArray(e.array)) {
                    arr[i] = toDArray(e);
                } else {
                    arr[i] = DArrayElt.getInstance(e);
                }
            }
            return new ADVariables(arrObj);
        }
        function toArray(arrObj) {
            var arr = arrObj.array, n = arr.length,e;
            for (var i = 0; i < n; i++) {
                e = arr[i];
                if (isPlainObject(e) && isArray(e.array)) {
                    arr[i] = toArray(e);
                } else {
                    arr[i] = Expression.getInstance(e);
                }
            }
            return new VArray(arrObj);
        }
        /**
         * 
         * @returns {Boolean|String}
         */
        function getOperator() {
            var op = regexMatch(regexps["destruct-operators"], str,i);
            if (op) {
                return op[0];
            }
            return false;
        }
        /**
         * 
         * @returns {String}
         */
        function getElt() {
            var _ctx;
            if (varray) {
                _ctx.offset = i;
                _ctx.stop = [',',']'];
                _ctx.comment = null;
                elt = parseExpression(str, _ctx);
                i = _ctx.index;
            } else if (nameStart(str, i)) {
                if (defaultValue || name) {
                    unexpectedChar(ch, lineNum, getColumn(i), i); //throw newError("Unexpected character");
                }
                name = regexMatch(nameRe, str, i)[0];
                start = i;
                lastLineNum = lineNum;
                i = skipSpaces(str, nameRe.lastIndex, n);
                elt.name = name;
                if (CHAINERS.indexOf(ch = str[i]) >= 0 || (op = getOperator())) {
                    if (destructuring) {
                        unexpectedChar(ch, lineNum, getColumn(i),i);
                    } else if ( !varray) {
                        varray = true;
                        arrObj = arr = new VArray(arrObj);
                    }
                    
                    _ctx = op ?  { object: new Reference(elt) } : cascade(str, i, n, [',',']'], new Reference(elt), regexps.name, "invocation", nameRe.lastIndex, lastLineNum);
                    _ctx.offset = i;
                    _ctx.stop = [',',']'];
                    _ctx.comment = null;
                    elt = parseExpression(str, _ctx, _ctx.object, true);
                    if (_ctx.comment) {
                        elt.setEndComment(_ctx.comment);
                    }
                    i = _ctx.index;
                    return elt;
                } else {
                    return name;
                }
            }
            
        }
        var start, op, varray, it, open= 1, arrayClosed;
        while (i < n) {
            ch = str[i];
            if ((it = getElt())) {                
                if (typeof it === 'string') {
                    elt.name = it;
                }
            } else if (ch === ',') {
                if (arrayClosed){
                    arrayClosed = false;
                } else {
                    add();
                }
                _cmt = processComments(str, lineNum, skipSpaces(str, i + 1, n), n, elt, 'outer', false);
                i = _cmt.index;
                _cmt = _cmt.comment;
                elt = {};
                if (_cmt) {
                    elt.comment = _cmt;
                    _cmt = null;
                }
            } else if (ch === ']') {                
                add();
                do { 
                    _cmt = processComments(str, (lastLineNum = lineNum), skipSpaces(str, i + 1, n), n, arrObj, 'outer', false);
                    i = _cmt.index;
                    _cmt = _cmt.comment;
                    open--;
                    if (stack.index < 0) {
                        break;
                    }                        
                    arrObj = stack.remove();
                    arr = hasOwnProp(arrObj, 'array') ? arrObj.array : arrObj;
                    ch = str[i];
                } while (ch === ']');
                if (open > 0){
                    arrayClosed = true;
                } else if (of) { 
                    if (!str.startsWith('of', i) || " \t\n\r\v\b\0".indexOf(str[i + 2]) < 0) {
                        //throw newError("Expected keyword 'of'");
                        expectedKeyword('of', str[i], lineNum, getColumn(i), i);
                    }
                    return {
                        index : i,
                        object : arrObj,
                        "of": true,
                        beforeOfComment : _cmt //before 'of' comments
                    };
                } else {
                    if (varray) {
                        if (str[i] === '=') {
                            unexpectedChar('=', str[i], lineNum, getColumn(i), i);
                        }
                        return arr;
                    }
                    if (destructuring) {
                        if (str[i] !== '=') {
                            expectedChar('=', str[i], lineNum, getColumn(i), i); //throw newError("Expected character");
                        }
                    } else if (str[i] !== '=') {
                        return toArray(arrObj);
                    }
                    
                    var comments = {};
                    _cmt = processComments(str, (lastLineNum = lineNum), skipSpaces(str, i + 1, n), n, comments, '', false);
                    i = _cmt.index;
                    var ctx = { offset: i, stop: statementEnders };
                    var expr = setComments(parseExpression(str, ctx), comments);
                    if (isArray(arr)) {
                        arr = toDArray(arrObj);
                    }
                    ctx.object = new ADAssign(arr, expr);
                    return endStatement(str,ctx);
                }
            } else if (ch === '[' || str.startsWith("?[", i)) {
                var a, aObj;
                if (ch ===  '?') {
                    if (varray) {
                        unexpectedChar(ch,lineNum,getColumn(i), i); //throw exception
                    }
                    i++;
                    if (!destructuring) {
                        arr = arrObj = toDArray(arrObj);
                        destructuring = true;
                    }
                    aObj = a = new ADVariables();
                    a.setArray(true);
                    a.setOptionalChaining(true);
                    if (_cmt) {
                        a.setComment(_cmt);
                    }
                    arr.add(a);
                } else if (destructuring) {
                    aObj = a = new ADVariables();
                    a.setArray(true);
                    if (_cmt) {
                        a.setComment(_cmt);
                    }
                    arr.add(a);
                } else if (varray) {
                    aObj = a = new VArray();
                    arr.add(a);
                    if (_cmt) {
                        a.setComment(_cmt);
                    }
                } else {
                    a = [];
                    arr[arr.length] = aObj = { array : a, comment: _cmt };
                }
                stack.add(arrObj);
                arr = a;
                arrObj = aObj;
                open++;
                lastLineNum = lineNum;
                lastIndex = i + 1;
                _cmt = processComments(str, lastLineNum, skipSpaces(str, i + 1, n), n, arrObj, 'inner', false);
                i = _cmt.index;
                _cmt = _cmt.comment;
            } else if (ch === '=') {
                if (varray || defaultValue || !name) {
                    unexpectedChar(ch, lineNum, getColumn(i), i); //throw new Error("Unexpected character");
                }
                if (!destructuring) {
                    arr = toDArray(arrObj);
                    destructuring = true;
                }
                lastLineNum = lineNum;
                lastIndex = i + 1;
                ctx.offset = i = skipSpaces(str, i + 1, n);
                if ((_cmt = _processComments(str,i, n))) {
                    ctx.offset = i = _cmt.index;
                    _cmt = _cmt.object;

                    //TODO
                }
                ctx.stop = [',', ']'];
                elt.defaultValue = defaultValue = parseExpression(str, ctx);
                i = ctx.index;                        
            } else if (str.startsWith("...", i)) {
                i += 3;
                var match, re = regexps['simple-name'];
                if (!(match = regexMatch(re, str, i))) {
                    throw new Error("Incorrect array destruring: expecting variable name after '...' at line number " + lineNum + ", column " + getColumn(i) + " and index " + i);
                }
                elt = new RestEName(name= match[0]);
                if (_cmt) {
                    elt.setComment(_cmt);
                }
                _cmt = processComments(str, lastLineNum, skipSpaces(str, i + 1, n), n, elt, '', true);
                i = _cmt.index;
                if (i !== ']') {
                    if (!(match = regexMatch(re, str, i))) {
                        throw new Error("Incorrect array destruring: expecting ']' after rest ('...') element at line number " + lineNum + ", column " + getColumn(i) + " and index " + i);
                    }
                }
            } else if (ch === '{') {
                
            } else if (arr.length === 0) {
                return parseArray(str, offset, n, ctx);
            } else if (varray) {
                ctx.offset = i;
                elt = parseExpression(str, ctx);                
            } else {
                unexpectedChar(ch, lineNum, getColumn(i), i); //throw newError("Unexpected character");
            }
        }
    }
    /**
     * 
     * @private
     * @param {type} str
     * @param {type} i
     * @param {type} n
     * @param {Boolean|String|Number} of
     * @param {Object} ctx
     * @returns {Object}
     */
    function parseArrayDestructuring(str, i, n, of, ctx) {
        if (isPlainObject(of)) {
            ctx = of;
            of = "";
        }
        if (ctx) {
            ctx.stop = [',', '}'];
        } else {
            ctx = { stop: [',', '}'] };
        }
        
        var ch, defaultValue, 
            destructArray = new ADVariables(), 
            nameRe = regexps['simple-name'], name,
            lastLineNum = lineNum,
            lastIndex,
            _cmt; 
        var open = 1, elt = {}, closed;
        //skip character '[' and spaces
        _cmt = processComments(str, lastLineNum, skipSpaces(str, i + 1, n), n, elt, '', false);
        i = _cmt.index;
        destructArray.setArray(true);
        var stack = {
            elts : [],
            index: -1,                    
            add: function(e) {
                this.elts[++this.index] = e;
            },
            remove: function() {
                e = this.elts[this.index];
                this.elts.splice(this.index--,1);
                return e;
            },
            size: function() {
                return this.elts.length;
            }
        };
        /**
         * 
         * @returns {undefined}
         */
        function addElt() {
            destructArray.add(elt);
            elt = {};
            if (_cmt) {
                elt.comment = _cmt;
                _cmt = null;
            }
            defaultValue = null;
            name = "";
        }
        
        function getContext(i, destructArray, _cmt, ctx) {
            if (ctx) {
                ctx.object = destructArray;
                ctx.index = i;
                ctx.comment = _cmt;
                return ctx;
            }
            return {
                    index : i,
                    object : destructArray,
                    comment : _cmt 
                };
        }
        function end() {
            if (Object.keys(elt).length) {
                destructArray.add(elt);
            }            
            _cmt = processComments(str, (lastLineNum = lineNum), skipSpaces(str, i + 1, n), n, destructArray, '', true);
            i = _cmt.index;
            if (str[i] === '=') {
                var comments = {};
                _cmt = processComments(str, (lastLineNum = lineNum), skipSpaces(str, i + 1, n), n, comments, '', false);
                i = _cmt.index;
                var ctx = { offset: i, stop: statementEnders };
                var expr = setComments(parseExpression(str, ctx), comments);
                ctx.object = new ADAssign(destructArray, expr);
                return ctx;
                //return endStatement(str,ctx);
            }
            if (of === true || of === 'of') {
                if (!str.startsWith('of', i) || " \t\n\r\v\b\0".indexOf(str[i + 2]) < 0) {
                    //throw newError("Expected keyword 'of'");
                    expectedKeyword('of', str[i], lineNum, getColumn(i), i);
                }
                return getContext(i, destructArray, _cmt, ctx);
            }
            if (of === 'ar' || of === 'arr' || of === 'sub') {                
                return getContext(i, destructArray, _cmt, ctx);
            } else {
                expectedChar('=', str[i], lineNum, getColumn(i), i); //throw newError("Expected character");
            }
        }
        
        
        while (i < n) {
            ch = str[i];
            if (nameStart(str, i)) {
                if (defaultValue || name) {
                    unexpectedChar(ch, lineNum, getColumn(i), i); //throw newError("Unexpected character");
                }
                elt.name = name = regexMatch(nameRe, str, i)[0];
                i = skipSpaces(str, nameRe.lastIndex, n);
            } else if (ch === '=') {
                if (elt instanceof ADVariables || elt instanceof ODVariables) {
                    elt = { type: 'varselt', variables : elt };
                } else if (defaultValue || !name) {
                    unexpectedChar(ch, lineNum, getColumn(i), i); //throw newError("Unexpected character");
                }
                lastLineNum = lineNum;
                lastIndex = i + 1;
                ctx.offset = i = skipSpaces(str, i + 1, n);
                if ((_cmt = _processComments(str,i, n))) {
                    ctx.offset = i = _cmt.index;
                    _cmt = _cmt.object;

                    //TODO
                }
                elt.defaultValue = defaultValue = parseExpression(str, ctx);
                i = ctx.index;                        
            } else if (ch === ',') {
                if (elt.type === 'rest') {
                    unexpectedChar(ch, lineNum, getColumn(i), i, "Unexpected character after destructuring rest/remain element"); //throw newError("Unexpected character");
                }
                _cmt = processComments(str, lineNum, skipSpaces(str, i + 1, n), n, elt, 'outer', false);
                i = _cmt.index;
                _cmt = _cmt.comment;
                addElt();
            } else if (ch === ']') {
                if (stack.size()) {
                    for (;;) {
                        if (open === 1) {
                            return end();
                        }
                        destructArray.add(elt);
                        elt = destructArray;                        
                        _cmt = processComments(str, (lastLineNum = lineNum), skipSpaces(str, i + 1, n), n, destructArray, '', true);
                        i = _cmt.index;
                        _cmt = _cmt.comment;
                        destructArray = stack.remove();
                        open--;
                        ch = str[i];
                        if (ch !== ']') {
                            defaultValue = null;
                            name = "";
                            break;
                        }
                    }
                } else {
                    return end();
                }
            } else if (ch === '[') {                
                var a = new ADVariables();
                a.setArray(true);
                stack.add(destructArray);
                destructArray = a;
                if (_cmt) {
                    destructArray.setComment(_cmt);
                }
                lastLineNum = lineNum;
                lastIndex = i + 1;
                _cmt = processComments(str, lastLineNum, skipSpaces(str, i + 1, n), n, destructArray, 'inner', false);
                i = _cmt.index;
                _cmt = _cmt.comment;
                open++;
            } else if (ch === '{') {
                var o = parseObjectDestructuring(str, i, n, "ar", ctx);
                i = o.index;
                elt = o.object;
            } else if (str.startsWith("...", i)) {
                if (defaultValue || name) {
                    unexpectedChar(ch, lineNum, getColumn(i), i); //throw newError("Unexpected character");
                }
                i += 3; 
                if ((name = regexMatch(nameRe, str, i))) {
                    elt.name = name[0];
                    elt.type = "rest";
                    i = skipSpaces(str, nameRe.lastIndex, n);
                    //TODO: process comments
                } else {
                    unexpectedChar(ch, lineNum, getColumn(i), i); //throw newError("Unexpected character");
                }
            } else {
                unexpectedChar(ch, lineNum, getColumn(i), i); //throw newError("Unexpected character");
            }
        }
    }
    /**
     * 
     * @private
     * @param {type} str
     * @param {Number|Object} i
     * @param {type} stop
     * @param {type} obj
     * @param {type} start
     * @returns {Object}
     */
    function endStatement(str, i, stop, obj, start) {                
        var result,ender, dStop;
        function end(str, i, ender, result) {
            result.lastIndex = i + ender.length;
            result.lastLineNum = lineNum;
            var cmt = processComments(str, lineNum, skipSpaces(str, result.lastIndex), str.length, obj, 'outer', false);
            result.index = cmt.index;
            result.comment = cmt.comment;
        }
        if (typeof i === 'object') {
            if (stop === true) {
                stop = i.stop;
                result = i;                        
                obj = i.object;
                dStop = i.dStop;
                ender = dStop ? dStop.ender : i.ender;
                i = i.index||i.lastIndex||i.offset||0;
            } else {                
                if (arguments.length < 4) {
                    obj = i.object;
                }
                if (i.ender) {
                    if (statementEnderSkipables[i.ender]) {
                        end(str, (i.index||i.lastIndex||i.offset||0), i.ender, i);
                    }
                }
                if (typeof arguments[2] === 'number') {
                    i.start = arguments[2];
                }
                return i;
            }
        }
        if (!((obj instanceof Statement)) && (obj instanceof Statement)) {
            obj = Statement.getInstance(obj);
        }
        if (ender) {
            if (statementEnderSkipables[ender]) { 
                end(str, i, ender, result);
            }
            result.object = obj;
            if (typeof start === 'number') {
                result.start = start;
            }
            return result;
        } else if (stop && stop.length) {
            var ro = isStop(str, i, stop, result);
            if (ro) {
                if (ro.ender) {
                    if (statementEnderSkipables[ro.ender]) {
                        end(str, i, ro.ender, ro);
                    }
                }
                ro.object = obj;
                if (typeof start === 'number') {
                    ro.start = start;
                }
                return ro;
            }
            unexpectedChar(str[i], lineNum, getColumn(i), i);
        }
        var ro;
        if (result) {
            ro = result;
            ro.object = obj;
            ro.index = i;
            ro.lastIndex = i;
        } else {
            ro = { object: obj, index: i, lastIndex: i};
        }
        if (typeof start === 'number') {
            ro.start = start;
        }
        return ro;
    }
    /**
     * 
     * @private
     * @param {String} str
     * @param { unsigned int} i
     * @param {Array} stop
     * @param {Expression|Object} expr
     * @param {Number} start
     * @param {Number} lastLineNum
     * @param {IComment} cmt
     */
    function endExpression(str, i, stop, expr, start, lastLineNum, cmt) {
        var ns = typeof SereniX !== 'undefined' && isPlainObject(SereniX) === 'object' ? SereniX.prog||window: window
        var ctx, 
                ChainedExpressions = ns.ChainedExpressions||ChainedExpressions, 
                Expression = ns.Expression||Expression,
                IComment = ns.IComment||IComment;
        if (typeof i === 'object') {
            if (!expr) {
                expr = i.object;
            }
            lastLineNum = i.lastLineNum;
            if (!stop) {
                stop = i.stop;
            }
            if (arguments.length < 4 || typeof arguments[4] !== 'number') {
                start = i.start;
            }
            if (arguments.length > 2 && arguments[2] instanceof IComment) {
                cmt = arguments[2];
            } else {
                cmt = i.comment;
            }
            ctx = i;
        } else {
            ctx = { lastIndex: i, index : i, object: expr, stop: stop };
            if (typeof start === 'number') {
                ctx.start = start;
            }
        }
        if (!(expr instanceof Expression)) {
            ctx.object = expr = Expression.getInstance(expr);
        }
        if (stop && stop.length) {
            var ro = isStop(str, ctx, stop, lastLineNum );
            if (ro) {                        
                if (ro.chain) {
                    ctx.chain[ctx.chain.length] = expr;
                    ro.object = new ChainedExpressions(ctx.chain);
                    ro.chain = null;
                } else {
                    ro.object = expr;
                }
                return ro;
            }
            var pos = i = typeof i === 'object' ? i.index : i;
            if (str[pos ] === chainedExpressionsDelim) {
                ctx.offset = skipSpaces(str, pos + 1, str.length);
                if (!ctx.chain) {
                    ctx.chain = [expr];
                } else {
                    ctx.chain[ctx.chain.length] = expr;
                }
                parseExpression(str, ctx);
            } else {
                unexpectedChar(str[pos], lineNum, getColumn(pos), pos);
            }
        }             
        return ctx;
    }
    /**
     * 
     * @private
     * @param {String} str
     * @param {unsigned int} i
     * @param {unsigned int} n
     * @param {Array} stop
     * @returns {Object}
     */
    function parseArray(str, i, n, stop) {
        var arr = parseList(str, i, n, [',', ']']);
        arr.object.type = 'array';
        return endExpression(str, arr, stop);
    }
    function processTempComments(str, lastLineNum, i, n, tmp, typ, end) {
        tmp.comment = null;
        tmp.inlineComment = null;
        tmp.innerComment = null;
        tmp.innerInlineComment = null;
        return processComments(str, lastLineNum, i, n, tmp, typ, end);
    }
    function setComments(e, cmts) {
        if (cmts.comment) {
            e.setComment(cmts.comment);
        }
        if (cmts.inlineComment) {
            e.setInlineComment(cmts.inlineComment);
        }
        if (cmts.innerCmment) {
            e.setInnerComment(cmts.innerCmment);
        }
        if (cmts.innerInlineComment) {
            e.setInnerlineComment(cmts.innerInlineComment);
        }
        return e;
    }
    /**
     * 
     * @private
     * @param {String} str
     * @param {unsigned int} i
     * @param {unsigned int} n
     * @param {Array} stop
     * @returns {Object}
     */
    function parseObject(str, i, n, stop) {
        function end() {
            obj.entries = entries;
            if (_cmt) {
                obj.endComment = _cmt;
            }
            ctx.lastLineNum = lineNum;
            ctx.lastIndex = i + 1;
            // skip character '}' and spaces
            _cmt = processComments(str, ctx.lastLineNum, skipSpaces(str, i + 1, n), n, obj, 'outer', false);
            ctx.index = _cmt.index;
            try {
                ctx.object = obj ? new VObject(obj) : new VObject();
                ctx.stop = stop;
                ctx.start = start;
                ctx.comment = _cmt = _cmt.comment;
                return endExpression(str, ctx);
            } catch (ex) {
                throw new Error("Error while parsing object\nLine number : " 
                        + lineNum + "\nColumn: " 
                        + getColumn(i) 
                        + "\nIndex: " + i, ex);
            }
        }
        
        function processSimplifiedEntry() {
            var ch = str[i];
            if (typeof objectSimplifiedSyntax === 'undefined' || !objectSimplifiedSyntax) {
                unexpectedChar(ch, lineNum, getColumn(i), i);
            }
            property = false;
            var returnType, params, body;
            function processCall() {
                cstop = ctx.stop;
                params = parseParams(str, i, n, ctx);
                i = params.index;
                var lastLineNum = params.lastLineNum;
                params = params.object;
                var returnType;
                if (str[i] === ':') {
                    returnType = processType(str, i, n, ctx, ['{']);
                    i = ctx.index;        
                }
                if (str[i] !== '{') {
                    throw new Error("Expected character '{', found '" + str[i] + "'"
                            + " at line " + lineNum + ", column " + (getColumn(i)) + " and index " + i);
                }
                ctx = parseBlock(str, i, n, _cmt, expressionAsStatement, ctx);
                _cmt = ctx.comment;
                i = ctx.index;
                body = ctx.object;
            }
            if (key === 'set' || key === 'get') {
                var nameRe = regexps['simple-name'];
                if (!(match = regexMatch(nameRe, str, i))) {                    
                   throw new Error("Expected " 
                            + (key === 'set' ? 'setter' : 'getter') 
                            + " property name. Found character '"+ str[i] + "'"
                            + " at line " + lineNum + ", column " + (getColumn(i)) + " and index " + i);
                }
                if (_cmt) {
                    qkey.setComment(_cmt);
                }
                lastLineNum = lineNum;
                i = skipSpaces(str, nameRe.lastIndex, n);
                if (i >= n) {
                    unexpectedEnd();
                }
                _cmt = processComments(str, lastLineNum, i, n, qkey, '', true);
                i = _cmt.index;
                _cmt = _cmt.comment;
                processCall();
                entry = new (key === 'get' ? EGetter : ESetter)(match[0], params, body);
                if (returnType) {
                    entry.setReturnType(returnType);
                }
                value = undefined;
            } else if (key === 'async') {
                var nameRe = regexps['simple-name'];
                if (!(match = regexMatch(nameRe, str, i))) {                    
                   throw new Error("Expected " 
                            + (key === 'set' ? 'setter' : 'getter') 
                            + " property name. Found character '"+ str[i] + "'"
                            + " at line " + lineNum + ", column " + (getColumn(i)) + " and index " + i);
                }
                lastLineNum = lineNum;
                i = skipSpaces(str, nameRe.lastIndex, n);
                if (i >= n) {
                    unexpectedEnd();
                }
                _cmt = processComments(str, lastLineNum, i, n, qkey, '', true);
                i = _cmt.index;
                _cmt = _cmt.comment;
                processCall();
                name = match[0];
                //TODO: check if keyword
                entry = EMethod(name, params, body);
                if (returnType) {
                    entry.setReturnType(returnType);
                }
                entry.setAsync(true);
                if (cstop) {
                    ctx.stop = cstop;
                }
            } else if (ch === '(') {
                processCall();
                var name = "";
                if (qkey instanceof VString) {
                    name = key;
                }
                entry = EMethod(name, params, ctx.object);
                if (returnType) {
                    entry.setReturnType(returnType);
                }
                if (cstop) {
                    ctx.stop = cstop;
                }
            } else if (ch === ',' || ch === '}') {
                if (qkey instanceof VString) {
                    value = undefined;
                    entry = new AutoRefEntry(qkey); 
                } else {
                    throw new Error("Not supported yet");
                }                
            }
        }
        function processKeyDelim() {
            lastLineNum = lineNum;
            ctx.offset = i = skipSpaces(str, i + keyDelim.length, n);
            _cmt = processTempComments(str, lastLineNum, i, n, valueComments, '', true);
            ctx.offset = i = _cmt.index;
            if ((value = parseExpression(str, ctx))) {
                setComments(value, valueComments);
                if (_cmt) {
                    //TODO : 
                }
                i = ctx.index;
                _cmt = ctx.comment;
                //TODO: process or set above _cmt
                //
                //
                
            } else {
                throw new Error("Incorrect object expression");
            }
        }
        
        var keyRe = regexps.key,
                key, match,
                obj = { },
                entries = [],
                start = i,
                lastLineNum = lineNum,
                ctx = {stop: [entryCloser, '}']};
        // skip character '{' and spaces
        i = skipSpaces(str, i + 1, n); 
        var _cmt = processComments(str, lastLineNum, i, n, obj, 'inner', false, '{');
        i = _cmt.index;
        _cmt = _cmt.comment;
        if (i < n && str[i] === '}') {
            return end();
        }
        var qkey, valueComments = {}, entry, _end;
        var value, property, cstop;
        while (i < n) {
            if ((match = regexMatch(keyRe, str, i))) {
                key = match[0];
                if (key[0] === "'" || key[0] === '"') {
                    qkey = QString.getInstance(key);
                    key = qkey.getValue();
                } else if (key[0] === "[") {
                    if (!CName.expressionParser) {
                        CName.expressionParser = ExpressionParser;
                        CName.DEFAULT_EXPRESSION_PARSER = ExpressionParser;
                    }
                    qkey = new CName(key);
                } else if (notKeywordKey && keywords.indexOf(key) >= 0) {
                    throw new Error("Key can not be a keyword: '" + key + "'");
                } else {
                    qkey = new VString(key);
                }
                if (_cmt) {
                    qkey.setComment(_cmt);
                }
                lastLineNum = lineNum;
                i = skipSpaces(str, keyRe.lastIndex, n);
                if (i >= n) {
                    unexpectedEnd();
                }
                _cmt = processComments(str, lastLineNum, i, n, qkey, '', true);
                i = _cmt.index;
                _cmt = _cmt.comment;
                // entry key delimiter (keyDelim) in javacript is character ':'
                if (str.startsWith(keyDelim, i)) { 
                    //skip the key delimiter and process the entry value : the  
                    //character ',' or '}' ended the expression of the value
                    processKeyDelim();                     
                } else {
                    //1- when str[i] === '(' process function parameters, body and
                    //   return type : the function name is the value of key if 
                    //   qkey is not a quoted string or "" otherwise
                    //2- when str[i] is character ',' or '}' the value is a 
                    //variable with name equals to key if qkey is not a quoted 
                    //string or otherwise a 'Not supported yet' exception is 
                    //thrown
                    processSimplifiedEntry();
                }
                if (value) {
                    entry = {key :  qkey, value: value};
                }               
                entries[entries.length] = entry; 
                //by default the entry closer is ','
                if (str.startsWith(entryCloser, i)) {
                    lastLineNum = lineNum;
                    // skip entry stop ',' for example
                    i = skipSpaces(str, i + entryCloser.length, n);
                    _cmt = processComments(str, lastLineNum, i, n, entry, 'outer', false);
                     i = ctx.index = _cmt.index;
                    _cmt = ctx.comment;
                    if (str.startsWith('}', i)) {
                        return end();    
                    }
                } else if (str.startsWith('}', i)) {
                    if (lineNum === 366) {
                        console.log("lineNum === 366");
                    }
                    return end();    
                } else {
                    //throw "Unepected character" exception
                    unexpectedChar(str[ctx.index], lineNum, ctx.index - lineOffset + 1, ctx.index, "Unexpected character: epecting ',' or '}'");
                }
            } else {
                throw new Error("Incorrect object expression. Expected object key/name, found character '" + str[i] + "'" );
            }
        }
        
        unexpectedEnd();
    }
    function parseDefaultValue(str, i, n, ctx) {
        i = skipSpaces(str, i, n);
        var cmt = _processComments(str, i, n);
        if (cmt) {
            i = skipSpaces(str, cmt.index, n);
            cmt = cmt.object;                    
        }
        ctx.offset = i;
        var v = parseExpression(str, ctx);                
        if (cmt) {
            v.setComment(cmt);
        }
        ctx.object = v;
        return ctx;
    }
    
    /**
     * 
     * @private
     * @param {String} str
     * @param {unsigned int} i
     * @param {unsigned int} n
     * @param {Object} [ctx]
     */
    function parseParams(str, i, n, ctx) { 
        
        var cmt, _cmt, stop = [',', ')' ],
                acmt, bcmt, inline;
        if (!ctx) {
            ctx = {stop : stop };
        } else {
            ctx.stop = stop;
        }
        //skip the character '('
        i = skipSpaces(str, i + 1, n);
        var parms = [], opts, name, re = regexps["simple-name"], ch, p, param, result;
        var option;
        while (i < n) {
            if ((cmt = _processComments(str, i, n))) {
                i = skipSpaces(str, cmt.index, n);
                cmt = cmt.object;
            } else if (str.startsWith("...", i)) {
                if (!(name = regexMatch(re, str, i + 3,n))) {
                    //throw "Unexpected character exception
                    unexpectedChar('.', lineNum, getColumn(i), i);
                }
                name = name[0];
                i = skipSpaces(str, re.lastIndex, n);
                if ((acmt = _processComments(str, i,  n))) {
                    //TODO
                    i = acmt.index;
                }
                param = new RestParam(name);
                if (cmt) {
                    param.setComment(cmt);
                }
                if (acmt) {
                    if (inline) {
                        p.setInlineComment(acmt);
                    } else {
                        p.setEndComment(acmt);
                    }
                }
                if (i < n && str[i] !== ')') {
                    //throw "Expected character exception
                    expectedChar(')', str[i], lineNum, getColumn(i), i);
                } else {
                    lastLineNum = lineNum;
                    i = skipSpaces(str, i + 1, n);
                    if ((cmt = _processComments(str, i,  n))) {
                        //TODO
                        i = cmt.index;
                    }
                    break;
                }
            } else if ((name = regexMatch(re, str, i))) {
                param = new Param(name[0]);
                if (cmt) {
                    param.setComment(cmt);
                    cmt = null;
                }
                _cmt = processComments(str, lineNum, skipSpaces(str, re.lastIndex, n), n, param, 'afterName', false);
                option = undefined;
                if (str[_cmt.index] === '?') {
                    param.setOptional(option = true);
                    _cmt = processComments(str, lineNum, skipSpaces(str, _cmt.index + 1, n), n, param, 'afterOption', false);
                }
                i = _cmt.index; 
                _cmt = _cmt.comment;
                if (str[i] === ':') {
                    if (!option) {
                        param.setOptional(false);
                    }
                    param.setType(processType(str, i, n, ctx, [',', ')', '=']));
                    i = ctx.index;
                }
            } else if ((ch = str[i]) === ',') {
                if (!param) {
                    unexpectedChar(ch, i);
                }
                if (cmt) {
                    param.setEndComment(cmt);
                    cmt = null;
                }
                parms[parms.length] = param;
                param = null;
                //i = skipSpaces(str, i + 1, n);
                _cmt = processComments(str, lineNum, skipSpaces(str, i + 1, n), n, param, 'outer', false);
                ctx.index = i = _cmt.index;
                _cmt = _cmt.comment;
            } else if (ch === '=') {
                if (cmt) {
                    //TODO
                    cmt = null;
                }
                parseDefaultValue(str, skipSpaces(str, i + 1, n), n, ctx);
                param.setValue(ctx.object);
                i = skipSpaces(str, ctx.index, n);
            } else if (ch === ')') {                        
                if (param) {                            
                    if (cmt) {
                        param.setEndComment(cmt);
                        cmt = null;
                    }
                    parms[parms.length] = param;
                }
                parms = new Params(parms);
                lastLineNum = lineNum;
                _cmt = processComments(str, lineNum, skipSpaces(str, i + 1, n), n, parms, 'outer', false);
                return getContext(ctx, _cmt.index, i + 1, parms, lastLineNum,_cmt.comment||_cmt.object);
            } else if (str[i] === '{') {
                if (parms.length > 0 ) {
                    unexpectedChar(ch, lineNum, getColumn(i), i); //throw exception
                }
                opts = parseObjectDestructuring(str, i, n, /* destructuring type argument */ "param");
                _cmt = processComments(str, opts.lastLineNum, opts.index, n, opts.object); 
                i = _cmt.index;
                _cmt = _cmt.comment;
                var _params = new Params([opts.object]);
                _params.setEndComment(_cmt);
                if (str[i] !== ')') {
                    unexpectedChar(ch, lineNum, getColumn(i), i); //throw exception
                }

                var lastLineNum = lineNum,
                    lastIndex = i + 1;
                i = skipSpaces(str, lastIndex, n);
                _cmt = processComments(str, lastLineNum, i, n, _params); 
                return getContext(ctx, _cmt ? _cmt.index: i, lastIndex, _params, lastLineNum,_cmt.comment||_cmt.object);
            } else {
                unexpectedChar(ch, lineNum, getColumn(i), i); //throw exception
            }
        }
        unexpectedEnd();
    }
    /**
     * 
     * @private
     * @param {RegExp} re
     * @param {String} str
     * @param {unsigned int} i  The offset
     * @returns {Array}
     */
    function regexMatch(re, str, i) {
        var o;
        re.lastIndex = o = i||0;
        var m = re.exec(str);
        return m && (m[0].length + o) === re.lastIndex ? m : null;
    }
    /**
     * 
     * @private
     * @param {String} str
     * @param {unsigned int} i
     * @param {unsigned int} n
     * @param {Array} stop
     * @param {String} keyword
     * @param {IComment} cmt
     * @returns {Object}
     */
    function parseDeclaration(str, i, n, stop, keyword, cmt, ctx) {
        var ch, cstop;
        if (isPlainObject(ctx)) {
            cstop = ctx.stop;
        } else {
            ctx = {};
        }
        if (arguments.length === 6) {
            if (arguments[5] instanceof IComment) {
                cmt = arguments[5];
            } else {
                ctx = arguments[5];
            }
        } else if (arguments.length > 6) {
            if (arguments[6] instanceof IComment) {
                ctx = arguments[5];
                cmt = arguments[6];
            } else {
                cmt = arguments[5];
                ctx = arguments[6];
            }
        }
        var name, nameRe = regexps["simple-name"], 
                variables = [],       
                match, 
                stmt =  { 
                    type: "declaration", 
                    variables: variables, 
                    symbol: keyword,
                    comment: cmt||null
                };
        var _stop = [statementEnder, paramDelim, blockEnder, unclosedStatementEnd], 
                end = false, _cmt, _acmt, _var,
                lastIndex, lastLineNum;
        ctx.stop = _stop; 
        var valued, destructuring = false;
        do {
            i = skipSpaces(str, i, n);
            if ((_cmt = _processComments(str, i, n))) {                            
                i = _cmt.index;
            }
            if ((match = regexMatch(nameRe, str, i))) {
                name = match[0];
                _var = new Variable(name);
                if (_cmt) {
                    _var.setComment(_cmt.object);
                    _cmt = null;
                }
                lastIndex = nameRe.lastIndex;
                lastLineNum = lineNum;
                i = skipSpaces(str, lastIndex, n);
                if ((_acmt = _processComments(str, i, n))) {                            
                    i = _acmt.index;  
                    _var.setAfterNameComment(_acmt, lastLineNum === _acmt.startLineNum);
                }
                ch = str[i];
                valued = false;
                if (isStop(str, i, _stop, lastLineNum, ctx)) {
                    if ((_acmt = _processComments(str, i, n))) { 
                        _var.setEndComment(_acmt, lastLineNum === _acmt.startLineNum);
                    }
                } else {                    
                    if (str[i] === ':' ) {                        
                        var _typ = processType(str, i, n, ctx, [',', ';', '=']);
                        _var.setType(_typ);
                        i = ctx.index;
                        if (str[i] === '=' ) {
                            valued = true;
                        }
                    } else if (str[i] === '=' ) {
                        valued = true;
                    } else {                        
                        unexpectedChar(str[i], lineNum, getColumn(i), i); //throw "unexpected character";
                    }
                    if(valued) {
                        if ((_acmt = _processComments(str, i, n))) { 
                            _var.setAfterNameComment(_acmt);
                        }
                        //skip character '=' and spaces
                        ctx.offset = skipSpaces(str, i + 1, n);
                        _var.setValue(parseExpression(str, ctx));
                        if (ctx.comment) {
                            _var.setAfterValueComment(ctx.comment);
                        }
                        lastIndex = ctx.lastIndex;
                        ch = str[lastIndex];
                        lastLineNum = ctx.lastLineNum;
                        i = skipSpaces(str, ctx.index, n);
                    }
                }
                variables[variables.length] = _var;     
            } else if (str[i] === '{') {
                ctx = parseObjectDestructuring(str, i, n, ctx);
                variables[variables.length] = ctx.object;
                i = ctx.index;
                valued = true;
                destructuring = true;
            }  else if (str[i] === '[') {
                ctx = parseArrayDestructuring(str, i, n, ctx);
                variables[variables.length] = ctx.object;
                i = ctx.index;
                valued = true;
                destructuring = true;
            } else {
                throw new Error("Expecting a variable name");
            }
            if (ctx.ender) {
                if (statementEnderSkipables[ctx.ender] || ctx.ender === declarationChainSymbol ) {
                    lastIndex = ctx.index + ctx.ender.length;
                    lastLineNum = lineNum;
                    _cmt = processComments(str, lastLineNum, skipSpaces(str, lastIndex, n), n, ctx.object, 'outer', false);
                    i = _cmt.index;
                    _cmt = _cmt.comment;
                    //if not declaration chaining variable
                    if (ctx.ender !== declarationChainSymbol) {
                        ctx.lastIndex = lastIndex;
                        ctx.index = i;
                        break; // end declaration : loop stop
                    }
                    //chain/add/parse new variable (preceeded by ',' character): loop will continue
                    
                    //initialize
                    destructuring = false; 
                } else {
                    break;
                }
            } else {//unclosed statement end : new line(s) followed by a new statement
                break;
            }
        } while (i < n);
        if (ctx.ender === declarationChainSymbol) {
            unexpectedEnd();
        }
        try {
            if (cstop) {
                ctx.stop = cstop;
            }
            return destructuring ? (ctx.object = new Declaration(stmt), ctx) : getContext(
                ctx, 
                i, 
                lastIndex, 
                new Declaration(stmt), 
                lastLineNum 
                //, comment
            );
        } catch (e) {
            throw e;
        }
    }
    /**
     * 
     * @private
     * @param {type} estop
     * @param {type} i
     * @param {type} str
     * @returns {Object|Boolean}
     */
    function _finalizeStop(estop, i, str) {
        if (isPlainObject(estop) && (estop.hasOwnProperty('lastIndex') || estop.hasOwnProperty('index'))) {
            if (!estop.hasOwnProperty('lastIndex')) {
                estop.lastIndex = i;
            } else if (!estop.hasOwnProperty('index')) {
                estop.index = estop.lastIndex;
            }
        } else {
            estop = { lastIndex : i, index: i };
        }
        return estop;
    }
    /**
     * Check if the given start position/index corresponds to a 
     * statement or expression ender.
     * <p>When the argument <b>stop</b> is undefined or null or it's 
     * length equals to zero, returns <b color="blue">null</b>.</p>
     * <p>When a substring starting at the start position/index 
     * corresponds to a statement ender, returns a plain object.</p>
     * @private
     * @param {type} str
     * @param {type} i  The start position/index
     * @param {Array&lt;String|Function|Stop&gt;} stop
     * @returns {Object|Boolean|null}
     * <p>When the return value is a plain object with the following 
     * properties/fields:</p>
     * <ul>
     * <li><b>ender</b>: the string symbol/marker that ends the 
     * statement. This property is optional;</li>
     * <li><b>lastIndex</b>: the position/index where the effective 
     * statement ends.</li>
     * <li><b>index</b>: the position/index of the ender when the 
     * statement is ended by an ender, otherwise the position of the 
     * next statement.</li>
     * </ul>
     * @todo Simplify this function to have only two parameter, the tring and an object that is the result
     */
    function isStop(str, i, stop, lastLineNum, result) {
        if (typeof arguments[3] === 'number') {
            lastLineNum = arguments[3];
            result = isPlainObject(arguments[4]) ? arguments[4] : undefined;
        } else if (isPlainObject(arguments[3])) {
            result = arguments[3];
            if (typeof arguments[4] === 'number') {
                lastLineNum = arguments[4];
            } else {
                lastLineNum = result.lastLineNum;
            }
        }

        if (isPlainObject(i)) {
            if (!result) {
                result = i;                        
            }
            if (typeof lastLineNum === 'undefined' || lastLineNum === null )
                lastLineNum = i.lastLineNum;
            if (!stop) {
                stop = i.stop;
            }
            i = i.index||i.offset||0;
        }


        if (!stop || stop.length === 0) {
            return null;
        }
        if (result) {
            result.ender = null;
        } else {
            result = {};
        }

        var estop;
        for (var k = 0, n = stop.length, s; k < n; k++) {
            s = stop[k];
            if (typeof s === 'string') {
                if (str.startsWith(s, i)) {
                    result.ender = s;
                    result.lastIndex = result.index = i;
                    return result;
                }
            } else if (typeof s === 'function') {
                if ((estop = s(str, i, lastLineNum, lineNum))) {                            
                    return _finalizeStop(estop, i, str);
                }
            } else if (s instanceof RegExp) {
                var match;
                if ((match=regexMatch(s, str, i))) {
                    result.ender = match[0];
                    result.lastIndex = result.index = i;
                    return result;
                }
            } else if (isPlainObject(s)) {
                if (typeof s.isStop === 'function') {
                    if ((estop = s.isStop(str, i, lastLineNum, lineNum, s))) {
                        return _finalizeStop(estop, i, str);
                    }
                } else if (typeof (s.stop||s.symbol) === 'string') {
                    if (str.startsWith(s.stop||s.symbol, i)) {
                        result.ender = s.stop||s.symbol;
                        result.lastIndex = result.index = i;
                        return result;
                    }
                } else if (typeof s.check === 'function') {
                    if ((estop = s.check(str, i, s)))
                        return _finalizeStop(estop, i, str);
                } else {
                    throw new Error("Incorrect stop");
                }
            } else if (isArray(s)) {
                var result = isStop(str, i, s, lastLineNum);
                if (result) {
                    return result;
                }
            } else {
                throw new Error("Incorrect stop");
            }
        }
        return false;
    }
    /**
     * 
     * @private
     * @param {type} str
     * @param {type} i
     * @param {type} n
     * @param {Object} chain
     * @param {type} stop
     * @returns {Object}             * 
     */
    function chainAssign(str, i, n, chain, stop) {
        var statements = chain.statements, ass;
        do {
            //skip the character ','
            i = skipSpaces(str, i + 1, n);
            ass = parseAssign(str, i, n, stop);
            statements[statements.length] = ass.object;
            i = ass.index;
        } while (i < n  && str[i] === ',');
        chain.statements = statements;
        return endExpression(str, i, stop, chain); 
    }
    /**
     * 
     * @param {String} str
     * @param {unsigned int} i
     * @param {unsigned int} n
     * @param {Array} stop
     * @returns {Object}
     */
    function parseAssign(str, i, n, stop) {
        var assignOps = regexps["assign-operators"], 
            assignSymbols = Operation.ASSIGN_OPERATORS;
        var _stop = [].slice.call(assignSymbols), 
                        ref;
                    _stop[_stop.length] = ';';
                    _stop[_stop.length] = '}';
        var match = parseRef(str, i, n, _stop);
        var ref = match.object;
        i = match.index;
        if (ref instanceof Reference || ref instanceof Index || ref.type === 'reference' || ref.type === 'index') {
            i = skipSpaces(str, match.index, n);
            if ((match = regexMatch(assignOps, str, i))) {
                var op = match[0], o, _ctx = { stop: ['=', ';', '}', ']', ',']};
                i = skipSpaces(str, assignOps.lastIndex, n);
                var left;
                if (op === '=') {    
                    left = [ref];
                    while (op === '=') {                                        
                        if (i >= n) {
                            unexpectedEnd(); //throw exception
                        }
                        _ctx.offset = i;
                        o = parseExpression(str, _ctx);
                        i = skipSpaces(str, _ctx.index, n);
                        if (str.startsWith('=', i)) {
                            if (o.type !== 'reference' && o.type !== 'index') {
                                unexpectedChar('=', i); //throw exception
                            }
                            left[left.length] = o;
                            op = '=';
                            i = skipSpaces(str, i + 1, n);
                        } else {
                            if (str.startsWith(';', i) 
                                    || str.startsWith('}', i) 
                                    || str.startsWith(']', i)) {
                                return  endExpression(str, i, stop, 
                                    { 
                                        type: 'assign', 
                                        operator: '=', 
                                        left: left, 
                                        value: o 
                                    } 
                                );
                            } else if (str.startsWith(',', i)) {
                                var chain = chainAssign(str, i, n, { 
                                        type: "chain-assign", 
                                        statements: [{ 
                                            type: 'assign', 
                                            operator: '=', 
                                            left: left, 
                                            value: o 
                                        }]}, 
                                    _stop);
                                return  endExpression(
                                    str, 
                                    chain.index,
                                    stop, 
                                    chain.object
                                );
                            } else {
                                unexpectedChar('=', i); //throw exception
                            }
                            op = null; 
                        }
                    }
                } else {
                    left = ref;                            
                    if (op !== '++') {
                        _ctx.offset = i;
                        o = parseExpression(str, _ctx);
                        i = _ctx.offset.index;
                    }
                    if (str.startsWith(';', i) 
                                    || str.startsWith('}', i) 
                                    || str.startsWith(']', i)) {
                        if (str.startsWith(';', i)) {
                            i = skipSpaces(str, i + 1, n);
                        }
                        return  endExpression(str, i, stop,
                            op === '++' ?
                            {
                                type: 'postfix',
                                operator: op, 
                                member: left
                            } :
                            { 
                                type: 'assign', 
                                operator: op, 
                                left: left, 
                                value: o 
                            }
                        );
                    } else if (str.startsWith(',', i)) {
                        var chain = chainAssign(str, i, n, { 
                                        type: "chain-assign", 
                                        statements: [
                                            op === '++' ?
                                            {
                                                type: 'postfix',
                                                operator: op, 
                                                member: left
                                            } : { 
                                                type: 'assign', 
                                                operator: op, 
                                                left: left, 
                                                value: o 
                                            }
                                        ]}, 
                                    _stop);
                        return  endExpression(
                                    str, 
                                    chain.index,
                                    stop, 
                                    chain.object
                                );
                    }
                }
            } else {
                unexpectedChar(); //throw exception
            }
        } else if (ref.type === 'invocation' || ref.type === 'instantiation') {
            return  endExpression(str, i, stop, ref);
        } else {
            unexpectedChar("not a statement"); //throw exception
        }
    }
    /**
     * 
     * @private
     * @param {type} str
     * @param {type} i
     * @param {type} n
     * @param {type} stop
     * @param {Object} _case
     * @returns {Array}
     */
    function getCStatement(str, i, n, stop, _case, ctx) {
        if (typeof i === 'number') {
            if (ctx) {
                
            } else {
                ctx = {};
            }
        } else {
            ctx = i;
            if (arguments.length < 4) {
                stop = i.stop;
            }
            i = ctx.index||0;
        }
        var condition = { };
        if (_case) {
             _case.condition = condition;
        } else {
            _case = {condition: condition};
        }
        //skip character '(' and the following spaces and process comments
        var _cmt = processComments(str, lineNum, i = skipSpaces(str, i + 1, n), n, condition, 'inner', false, '(');
        i = _cmt.index;
        ctx.offset =  i; 
        ctx.stop =  [ ')'];                
        condition.condition = parseExpression(str, ctx);  
        if (_cmt.comment) {
            condition.condition.setComment(_cmt.comment);
        }
        var s;
        //skip character ')' and the following spaces and process comments
        _cmt = processComments(str, lineNum, skipSpaces(str, ctx.index + 1, n), n, condition, '', true);
        ctx.index = i = _cmt.index;
        if (str[i] === '{') {
            s = parseBlock(str, ctx, n, _cmt.comment, expressionAsStatement);
        } else {
            s = parseStatement(str, ctx, n, stop, _cmt.comment );
        }

        _case.body = s.object;
        s.object = _case;
        s.index = skipSpaces(str, s.index, n);
        return s;
    }
/**
* 
* @param {type} str
* @param {type} i
* @param {type} n
* @param {type} stop
* @returns {While}
* @private
*/
function parseWhile(str, i, n, stop, ctx) {
    if (str[i] !== '(') {
        unexpectedChar(str[i], lineNum, getColumn(i), i);//throw "Unexpected character";
    }                
    var cs = getCStatement(str, i, n, stop, null, ctx);
    cs.object = new While(cs.object);
    return cs;
}

/**
* 
* @param {type} str
* @param {type} i
* @param {type} n
* @param {type} stop
* @param {IComment} cmt
* @param {Object} ctx
* @returns {DoWhile}
* @private
*/
function parseDo(str, i, n, stop, cmt, ctx) {
    // 'do' keyword already skipped
    
    
    if (arguments.length === 5) {
        if (cmt instanceof IComment) {
            ctx = null;
        } else {
            ctx = arguments[4];
            cmt = null;
        }
    } else if (arguments.length > 5) {
        if (arguments[4] instanceof IComment) {
            cmt = arguments[4];
            ctx = arguments[5];
        } else {
            ctx = arguments[4];
            cmt = arguments[5];
        }
    }

    var s;
    if (str[i] === '{') {
        s = parseBlock(str, i, n, stop, expressionAsStatement);
    } else {
        s = parseStatement(str, i, n, stop);
    }
    i = skipSpaces(str, s.index, n);
    if (str.startsWith("while ", i) 
            || str.startsWith("while\t", i)
            || str.startsWith("while\n", i) 
            || str.startsWith("while\r", i)) {
        i = skipSpaces(str, i + 6, n);
        if (str[i] !== '(') {
            unexpectedChar(str[i], lineNum, getColumn(i), i);//throw "Unexpected character";
        }
        //skip character '(' and spaces
        i = skipSpaces(str, i + 1, n);
    } else if (str.startsWith("while(", i)) {
        //skip string 'while(' and spaces
        i = skipSpaces(str, i + 6, n);
    } else {
        unexpectedChar(str[i], lineNum, getColumn(i), i);
    }               
    s.ender = "";
    s.offset = i;
    s.stop = [ ')'];
    s.object = new DoWhile(s.object, parseExpression(str, s));
    if (cmt) {
        s.object.setComment(cmt);
    }
    //skip condition ender character ')' and spaces and process end comments
    cmt = processComments(str, lineNum, i = skipSpaces(str, s.index + 1, n), n, s.object, '', true);
    i = cmt.index;
    cmt = cmt.comment;        
    if (str[i] === ';') {
        if (cmt) {
            s.object.setEndComment(cmt);
        }
        s.lastIndex = i + 1;
        cmt = processComments(str, lineNum, i = skipSpaces(str, i + 1, n), n, s.object, 'outer', false);
        s.index = cmt.index;
        cmt = cmt.comment;
    } else {
        s.lastIndex = s.index + 1;
        s.index = i;
    }
    s.comment = cmt;
    return s;
}
/**
* 
* @private
* @param {type} str
* @param {type} i
* @param {type} n
* @param {type} stop
* @param {Object} ctx
* @returns {For|ForIn|ForOf}
*/
function parseFor(str, i, n, stop, ctx) {
    //'for' keyword already skipped
    
    
    function _comment(_cmt) {
        return _cmt? _cmt.object ? _cmt.object : _cmt: null;
    }
    
    var ctl = {}, awaitComments;
    
    
    
    var _cmt = processComments(str, ctx.lastLineNum, i, n, ctl, '', false);
    i = _cmt.index;
    
    if (str.startsWith("await", i)) {
        if (" \t\n\r\b\v\0".indexOf(str[i+5]) < 0) {
            unexpectedChar(str[i], lineNum, getColumn(i), i);//throw "Unexpected character";
        }
        awaitComments = ctl;
        ctl = {};
        _cmt = processComments(str, ctx.lastLineNum, i, n, ctl, '', false);
        i = _cmt.index;
    }
    
    if (str[i] !== '(') {
        unexpectedChar(str[i], lineNum, getColumn(i), i);//throw "Unexpected character";
    }
    var _obj = {};
    _cmt = processComments(str, lineNum, skipSpaces(str, i + 1, n), n, _obj, '', false);
    i = _cmt.index;
    var cstop;
    if (ctx) {
        cstop = ctx.stop;
    } else {
        ctx = {};
    }

    var c = ctx, 
        f, //The for definition/metadata object used to create the 'for' statement object
        re = /(?:(var|let|const)\s+)?\s*([a-zA-Z$_][a-zA-Z$_0-9]*)(?:\s+(in|of)\s+)?|\s*;|(var|let|const)\s*(?:(\{|\[)\s*)/g,
        match = regexMatch(re, str, i), lastLineNum, startLineNum, lastIndex;

    function forIn() {
        if (awaitComments) {
            throw new Error("Expected 'of' keyword, found 'in'");
        }
        lastLineNum = lineNum;
        lastIndex = re.lastIndex;
        i = skipSpaces(str, re.lastIndex, n);
        if ((_cmt = _processComments(str, i, n))) {
            i = _cmt.index;
            //TODO
        }
        c.offset = i, c.stop = [')'];
        f = { 
            type: 'forin', 
            declaration : match[1], 
            variable: match[2], 
            object:  parseExpression(str, c )
        };
        lastLineNum = lineNum;
        lastIndex = c.index + 1;
        i = c.index = skipSpaces(str, c.index + 1, n);
        if ((_cmt = _processComments(str, i, n))) {
            i = _cmt.index;
            //TODO
        }
    }
    function forOf() {
        lastLineNum = lineNum;
        lastIndex = re.lastIndex;
        i = skipSpaces(str, re.lastIndex, n);
        if ((_cmt = _processComments(str, i, n))) {
            i = _cmt.index;
            //TODO
        }
        c.offset = i, c.stop = [')'];
        f = { 
            type: 'forof', 
            declaration : match[1], 
            await: !!awaitComments,
            variable: match[2], 
            iterable:  parseExpression(str, c ) 
        };
        i = c.index = skipSpaces(str, c.index + 1, n);
    }
    function forOfNoDeclarator() {
        var ref = /([a-zA-Z$_][a-zA-Z$_0-9]*)\s+/g;
        if (!(match = regexMatch(ref, str, i))) {
            unexpectedChar(str[i], lineNum, getColumn(i), i); //throw "Unexpected character";
        } 
        lastLineNum = lineNum;
        lastIndex = re.lastIndex;
        i = skipSpaces(str, re.lastIndex, n);
        if ((_cmt = _processComments(str, i, n))) {
            i = _cmt.index;
            //TODO
        }
        c.offset = i, c.stop = [')'];
        f = { 
            type: 'forof', 
            await: true,
            declaration : "", 
            variable: match[1], 
            iterable:  parseExpression(str, c ) ,
            awaitComments: awaitComments
        };
        i = c.index = skipSpaces(str, c.index + 1, n);
    }
    function forInNoDeclarator() {
        var ref = /([a-zA-Z$_][a-zA-Z$_0-9]*)\s*([\.]|\[)/g;
        if (!(match = regexMatch(ref, str, i))) {
            unexpectedChar(str[i], lineNum, getColumn(i), i); //throw "Unexpected character";
        } 
        f = { 
            type: 'forin', 
            reference : match[1], 
            chainSymbol: match[2]
        };
        var _start = i;
        i = ref.lastIndex;
        var _stop;
        var r = chainRef(new Reference(match[1]), str, _stop, n, _start, i, i, lineNum, [ '[', '.']);
        f.reference = r.object;
        lastLineNum = lineNum;
        lastIndex = r.lastIndex;
        i = skipSpaces(str, r.index, n);                    
        if ((_cmt = _processComments(str, i, n))) {
            i = _cmt.index;
            //TODO
        }

        if (!str.startsWith('in', i) || " \t\n\r\v\b\0".indexOf(str[i + 2]) < 0) {
            //throw newError("Expected keyword 'in'");
            expectedKeyword('in', str[i], lineNum, getColumn(i), i);
        }
        lastLineNum = lineNum;
        lastIndex = i + 2;
        i = skipSpaces(str, i + 2, n);                   
        if ((_cmt = _processComments(str, i, n))) {
            i = _cmt.index;
            //TODO
        }
    }
    
    function destructForOf() {
        var r = match[5] === '[' 
                ? parseArrayDestructuring(str, i, n, "of") //processArray(str, i, n, "of")
                : parseObjectDestructuring(str, i, n, "of");
        i = skipSpaces(str, r.index + 2, n);
        if ((_cmt = _processComments(str, i, n))) {
            i = _cmt.index;
            //TODO
        }
        c.offset = i, c.stop = [')'];
        f = { 
            type: 'forof', 
            declaration : match[4], 
            await: !!awaitComments,
            destructuring : match[5] === '[' ? 'array' : 'object', 
            variables : r.object,
            iterable:  parseExpression(str, c ),
            awaitComments: awaitComments
        };
        i = c.index = skipSpaces(str, c.index + 1, n);
    }
    
    function _for() {
        if (awaitComments) {
            throw new Error("Expected 'of' keyword");
        }
        var s;
        f = { type: 'for', control : ctl };
        if (str[i] === ';') {  //No initialiation case          
            _cmt = processComments(str, lineNum, skipSpaces(str, i + 1, n), n, _obj, 'outer', false);
            i = _cmt.index;
            _cmt = _cmt.comment;
            if (_obj.comment || _obj.inlineComment) {
                ctl.init = new EmptyStatement(_obj);
            }
            _obj = _cmt ? {comment: _cmt} : {};
        } else { 
            c.offset = i, c.stop = [';'];
            s = parseStatement(str, i, n, [';'], /* comment(s) */ _obj.comment || _obj.inlineComment ? _obj : null, /* context */ c);
            ctl.init = s.object;
            i = s.index;
            _obj = s.comment ? {comment: s.comment} : {};
            s.comment = null;
        }
        if (str[i] === ';') { //no condition case
            i = i + 1;
        } else {
            c.offset = i, c.stop = [';'];
            var e = parseExpression(str, c );  
            if (_obj.comment) {
                e.setComment(_obj.comment);
            }
            if (_obj.inlineComment) {
                e.setInlineComment(_obj.inlineComment);
            }            
            i = c.index + 1;
            _obj = e;
        }
        
        _cmt = processComments(str, lineNum, skipSpaces(str, i, n), n, _obj, 'outer', false);
        i = _cmt.index;
        _cmt = _cmt.comment;
        ctl.condition = _obj;
        _obj = _cmt ? {comment: _cmt} : {};
        if (str[i] === ')' ) {    //no increment statement case   
            ctl.increment = new EmptyStatement(_obj);            
        } else {
            c.offset = i, c.stop = [')'];
            s = parseStatement(str, i, n, [')'], /* comments */ _obj.comment || _obj.inlineComment ? _obj : null, c);
            ctl.increment = s.object;
            c.lastLineNum = lineNum;
            i = s.index;
        }
        c.lastIndex = i + 1;
        c.lastLineNum = lineNum;
        //skip ')' and spaces and process outer comments
        _cmt = processComments(str, lineNum, skipSpaces(str, i + 1, n), n, ctl.increment, 'outer', false);            
        c.index = i = _cmt.index;
        _cmt = _cmt.comment;
    }
    
    if (!match) {        
        if (awaitComments) {
            forOfNoDeclarator();
        } else {
            forInNoDeclarator();
        }
    } else if (match[3] === 'in') {
        forIn();
    } else if (match[3] === 'of') {
        forOf();
    } else if (match[5] === '{' || match[5] === '[') { // for of destructuring
        destructForOf();
    } else {
        _for();
    }

    var s = str[i] === '{' ? 
        parseBlock(str, c.index, n, _comment(_cmt), expressionAsStatement, c) : 
                parseStatement(str, skipSpaces(str, c.index, n), n, stop, _comment(_cmt), c);                    
    f.body = s.object;
    c.object = Statement.getInstance(f);
    c.index = s.index;
    c.lastIndex = s.lastIndex; 
    if (cstop) {
        ctx.stop = cstop;
    }
    return c;
}
/**
* 
* @private
* @param {String} str
* @param {unsigned int} i
* @param {unsigned int} n
* @param {Array} stop
* @param {Object} ctx
* @returns {Object}
*/
function parseThrow(str, i, n, stop, ctx) {
    //keyword 'throw' already skipped
    
    var comments = {};
    var _cmt = processComments(str, ctx.lastLineNum, i, n, comments, 'afterKeyword', false);
    i = _cmt.index;

    ctx.offset = i;
    ctx.ender = null;
    var t = new Throw(parseExpression(str, ctx));
    if (_cmt.comment) {
        //set the comment of the expression
        ctx.object.setComment(_cmt.comment);
    }
    
    if (comments.afterKeywordInlineComment) {
        t.setAfterKeywordInlineComment(comments.afterKeywordInlineComment);
    }
    if (comments.afterKeywordComment) {
        t.setAfterKeywordComment(comments.afterKeywordComment);
    }
    ctx.object = t;
    return  endStatement(str, ctx);
}

/**
* 
* @private
* @param {String} str
* @param {Object} ctx
* @param {unsigned int} n
* @param {IComment} cmt
* @returns {Object}
*/
function parseBreak(str, ctx, n) {
    //break keyword already skipped 


    var comments = {};
    var i = ctx.offset;
    var _cmt = processComments(str, lineNum, i, n, comments, 'afterKeyword', false);
    i = _cmt.index;
    var label;
    if (i < n) {
        var re = regexps['simple-name'];
        label = regexMatch(re, str, i);                    
    }
    if (label) {
        ctx.lastIndex = re.lastIndex;
        ctx.lastLineNum = lineNum;
        ctx.index = skipSpaces(str, re.lastIndex, n);
        _cmt = processComments(str, ctx.lastLineNum, ctx.index, n, comments, 'afterLabel', false);
        ctx.index = _cmt.index;
        ctx.object = new Break(label[0], comments);
    } else {
        ctx.object = new Break(comments);
        ctx.index = i;
    }
    if (!isStop(str, ctx, statementEnders)) {
        unexpectedChar(); //throw unexpected character
    }
    return endStatement(str, ctx, true);
}
/**
* 
* @private
* @param {String} str
* @param {Object} ctx
* @param {unsigned int} n
* @returns {Object}
*/
function parseContinue(str, ctx, n) {
    //'continue' keyword already skipped 


    var comments = {};
    var i = ctx.offset;
    var _cmt = processComments(str, lineNum, i, n, comments, 'afterKeyword', false);
    i = _cmt.index;
    var label;
    if (i < n) {
        var re = regexps['simple-name'];
        label = regexMatch(re, str, i);                    
    }
    if (label) {
        ctx.lastIndex = re.lastIndex;
        ctx.lastLineNum = lineNum;
        ctx.index = skipSpaces(str, re.lastIndex, n);
        _cmt = processComments(str, ctx.lastLineNum, ctx.index, n, comments, 'afterLabel', false);
        ctx.index = _cmt.index;
        ctx.object = new Continue(label[0], comments);
    } else {
        ctx.object = new Continue(comments);
        ctx.index = i;
    }
    if (!isStop(str, ctx, statementEnders)) {
        unexpectedChar(); //throw unexpected character
    }
    return endStatement(str, ctx, true);
}
/**
* 
* @private
* @param {String} str
* @param {Object} ctx
* @param {unsigned int} n
* @param {IComment} cmt
* @returns {Object}
*/
function parseTry(str, ctx, n, cmt) {
    //function parseTry(str, i, n, stop, keyword, start) {

    var i = ctx.offset, _cmt;

    if ((_cmt = _processComments(str, i, n))) {
        i = _cmt.index;
        //TODO
    }

    //The 'try' key already getted and skipped
    if (str[i] !== '{') {
        unexpectedChar(str[i], lineNum, getColumn(i), i);//throw "Unexpected character";
    }
    var _try, body = parseBlock(str, i, n, null /* stop */ , expressionAsStatement);
    i = skipSpaces(str, body.index, n);
    body = body.object;
    if ((_cmt = _processComments(str, i, n))) {
        i = _cmt.index;
        //TODO
    }
    var cbody; //catch body
    if (str.startsWith('catch', i)) {
        i = skipSpaces(str, i + 5, n);
        if ((_cmt = _processComments(str, i, n))) {
            i = _cmt.index;
            //TODO
        }
        if (str[i] !== '(')  {
            throw new Error("Character '(' expected at index " + i);
        }
        //skip character '(' and spaces
        i = skipSpaces(str, i + 1, n);
        if ((_cmt = _processComments(str, i, n))) {
            i = _cmt.index;
            //TODO
        }
        var re = regexps['simple-name'];
        //read the eception variable name of the catch 
        var match = regexMatch(re, str, i);
        if (!match) {
            throw new Error("Catch exception variable name expected");
        }
        if (JS_KEYWORDS.indexOf(match[0]) >= 0) {
            throw new Error("Unexpected '" + match[0] + "' keyword");
        }
        //skip spaces
        i = skipSpaces(str, re.lastIndex, n);
        if ((_cmt = _processComments(str, i, n))) {
            i = _cmt.index;
            //TODO
        }
        if (str[i] !== ')')  {
            throw new Error("Character '{' expected at index " + i);
        }
        //skip character ')' and spaces
        i = skipSpaces(str, i + 1, n);
        if ((_cmt = _processComments(str, i, n))) {
            i = _cmt.index;
            //TODO
        }
        if (str[i] !== '{')  {
            throw new Error("Character '{' expected at index " + i);
        }
        // parse the catch block
        cbody = parseBlock(str, i, n, null /* stop */, expressionAsStatement);

        _try = new Try(body, new Catch(match[0], cbody.object));

        i = skipSpaces(str, cbody.index, n);
        if ((_cmt = _processComments(str, i, n))) {
            i = _cmt.index;
            //TODO
        }
    }
    
    re = regexps['finally'];
    //if the finally block exists
    if ((match = regexMatch(re, str, i))) {
        i = skipSpaces(str, re.lastIndex, n);
        if ((_cmt = _processComments(str, i, n))) {
            i = _cmt.index;
            //TODO
        }
        if (str[i] !== '{')  {
            throw new Error("Character '{' expected at index " + i);
        }
        _try = new Try(body, null);
        body = parseBlock(str, i, n, null /* stop */, expressionAsStatement);        
        _try.setFinally(body.object);
        i = skipSpaces(str, body.index, n);
    } else if (!cbody) { //if catch block not encountered
        throw new Error("'catch' keyword or 'finally' keyword expected at index " + i);
    }
    ctx.index = i;
    return endStatement(str, i, null, _try); 
}
/**
* 
* @param {type} str
* @param {type} i
* @param {type} n
* @param {type} stop
* @param {IComment} cmt
* @param {Object} [ctx]
* @returns {If}
* @private
*/
function parseIf(str, i, n, stop, cmt, ctx) {
    if (isPlainObject(i)) { 
        ctx = i;
        i = i.index; 
    } else {
        if (isPlainObject(ctx)) {
            ctx.index = i;
        } else {
            ctx = { index : i};
        }
    }
    if (arguments.length === 5) {
        if (arguments[4] instanceof IComment) {
            cmt = arguments[4];
        } else {
            ctx = arguments[4];
        }
    } else if (arguments.length > 5) {
        if (arguments[5] instanceof IComment) {
            ctx = arguments[4];
            cmt = arguments[5];
        } else {
            cmt = arguments[4];
            ctx = arguments[5];
        }
    }
    if (str[i] !== '(') {
        unexpectedChar(str[i], lineNum, getColumn(i), i);//throw "Unexpected character";
    }
    var _cmt;
    if ((_cmt = _processComments(str, i, n))) {
        //TODO
        i = _cmt.index;
    }
    var cs = getCStatement(str, ctx, n, stop), 
            cases = [cs.object];
    i = cs.index;
    var _if = { type : "if", cases : cases, comment: cmt };
    var key, _case;
    while (i < n) {
        if (isWord(str, i, "else", n)) {                ;
            _case = { comment: cs.comment };
            _cmt = processComments(str, lineNum, i = skipSpaces(str, i + 4, n), n, _case, 'afterElse', false);
            i = _cmt.index;                
            if (isWord(str, i, "if", n)) { // 'else if' case
                _cmt = processComments(str, lineNum, i = skipSpaces(str, i + 2, n), n, _case, 'afterIf', false);
                i = _cmt.index;
                ctx.index = i;
                cs = getCStatement(str, ctx, n, stop, _case);
                _if.cases[_if.cases.length] = cs.object;
                i = cs.index;
            } else {
                ctx.index = i;
                if (str[i] === '{') {
                    _case.body = parseBlock(str, ctx, n, null /* stop */, expressionAsStatement).object;                   
                } else {
                    _case.body = parseStatement(str, i, n, stop, ctx).object;
                }
                _if.else = _case;
                break;
            }
        } else {
            break;
        }
    }
    //ctx.object = new If(_if);
    try {
        ctx.object = new If(_if);
        return ctx;
    } catch (e) {
        console.log("Line number: " + lineNum);
        throw e;
    }
    return ctx;
}
/**
* 
* @private
* @param {String} str
* @param {Object} ctx
* @param {unsigned int} n
* @param {IComment} cmt
* @returns {Object}
*/
function parseReturn(str, ctx, n, cmt) {
    var p = ctx.offset, dStop, _cmt, comments = {};
    _cmt = _cmt = processComments(str, ctx.lastLineNum, p, n, comments, '', false);
    p = _cmt.index;

    if (p < n) {
        if ((dStop = isStop(str, p, ctx.stop, ctx.lastLineNum))) {
            ctx.object = new Return(cmt);
            if (dStop.ender) {
                if (comments.inlineComment) {
                    ctx.object.setInlineEndComment(comments.inlineComment);
                }
                if (comments.comment) {
                    ctx.object.setEndComment(comments.comment);
                }
                ctx.comment = null;
            } else {
                ctx.comment = comments.inlineComment || comments.comment ? comments : null;
            }
            ctx.index = p;
            ctx.lastIndex = p;
            ctx.lastLineNum = lineNum;
            ctx.ender = dStop.ender;
            return endStatement(str, ctx);
        }
        ctx.object = new Return(parseExpression(str, ctx), cmt);
        return endStatement(str, ctx);
    } else {
        ctx.object = new Return(cmt);
        return  endStatement(str, ctx);
    }
}
function getInlineComment(comments) {
    var _cmt, column, c, columns = [];
    while (comments._comments.length > 0) {
        if (!_cmt) {
            column = comments._columns[0];
            _cmt = comments.remove(0);
        } else if (column <= comments._columns[0]) {
            if (_cmt instanceof Comment) {
                c = new Comments();
                c.add(_cmt);                                
                columns[0] = column;
                columns[1] = comments._columns[0];
                c.add(comments.remove(0));
                _cmt = c;
            } else {
                columns[1] = comments._columns[0];
                _cmt.add(comments.remove(0));
            }
        } else {
            break;
        }
    }
    return _cmt;
};
    /**
     * 
     * @private
     * @param {type} str
     * @param {type} p
     * @param {type} n
     * @returns {Number}
     */
    function _commentEnd(str, p, n) {
        var _newLine, nl, delims = newLine.length;
        while (p < n ) {
            _newLine = false;
            for (var k = 0; k < delims; k++) {
                nl = newLine[k];
                if (str.startsWith(nl, p)) {                            
                    p += nl.length;
                    if (p <= n) {
                        lineOffset = p;
                        lineNum++;
                        _newLine = true;
                    } else {
                        break;
                    }
                }
            }
            if (!_newLine) { // if not newline character '\n' or new line sequence '\r\n'
                if (str.startsWith(Comment.MULTI_LINE_CLOSE_SYMBOL, p)) {
                    return p + Comment.MULTI_LINE_CLOSE_SYMBOL.length;                            
                } else {
                    p++;
                }
            }
        }
        if (p === n) {
            unexpectedEnd();
        }
    }
    /**
     * 
     * @param {type} str
     * @param {type} i
     * @param {type} n
     * @returns {Object|null}
     */
    function _processComments(str, i, n) {
        function addComment(c, column) {
            var n, lineNum, inline;
            if (typeof lastLineNum === 'undefined') {
                n = 0;
                inline = false;
            } else {
                n = sLineNum - lastLineNum - 1;
                if (n < 0) {
                    inline = true;
                    n = 0;
                } else {
                    inline = false;
                }
            }
            c.setStartEmptyLines(n);
            if (cmt === null) {
                cmt = c;
                columns = [column];
            } else if (cmt instanceof Comment) {
                cs = new Comments();
                cs.add(cmt);
                cs.add(c, inline);
                cmt = cs;
                columns[columns.length] = column;
            } else {
                cmt.add(c, inline);
                columns[columns.length] = column;
            }
        }
        var cmt = null, p, cs, nl = /\n|\r(?:\n)?/g, lastIndex = i, 
                startLineNum = null, 
                start, lastLineNum, column, columns, sLineNum;
        while(i < n) {                    
            if (str.startsWith(Comment.MULTI_LINE_OPEN_SYMBOL, i)) {
                sLineNum = lineNum;
                column = getColumn(i);
                if (startLineNum === null) {
                    startLineNum = lineNum;
                    start = i;
                }
                p = _commentEnd(str, i + Comment.MULTI_LINE_OPEN_SYMBOL.length, n);
                addComment(new Comment(str.substring(i, p)), column);
                lastIndex = p;
                lastLineNum = lineNum;
                i = skipSpaces(str, p, n);
            } else if (str.startsWith("//", i)) {
                sLineNum = lineNum;
                column = getColumn(i);
                nl.lastIndex = i + 2;                        
                if (startLineNum === null) {
                    startLineNum = lineNum;
                    start = i;
                }
                if (nl.exec(str)) {                            
                    addComment(new Comment(str.substring(i, nl.lastIndex)), column);
                    lastLineNum = lineNum;
                    lineNum++;
                    lineOffset = lastIndex = nl.lastIndex ;
                    i = skipSpaces(str, lastIndex, n);
                } else {
                    addComment(new Comment(str.substring(i)), column);
                    i = lastIndex = n;
                }                      
            } else {
                break;
            }
        }
        if (cmt instanceof Comments) {
            cmt.setColumns(columns);
        }
        return  cmt ? { 
            startLineNum: startLineNum,
            start: start,
            object: cmt, 
            lastLineNum: lastLineNum,
            lastIndex: lastIndex, //the last index of the comments :  the index after the last '*/' when the last comment is multiline line comment or the index after the new line that follows the '//' of the last comment
            index: i, //the index of the non space character after the last comment 
            lineNum: lineNum,
            columns : columns
        } : null;
    }
/**
 * 
 * @param {String} str
 * @param {Number} lastLineNum
 * @param {Number} i
 * @param {Number} n
 * @param {type} elt
 * @param {type} type
 * @param {type} end
 * @param {type} opener
 * @returns {Object}
 */
function processComments(str, lastLineNum, i, n, elt, typ, end, opener) {
    function set(elt, key, cmt) {
        if (elt instanceof StatementElt || elt instanceof Expression) {
            key = "set" + key[0].toUpperCase() + key.substring(1);
            elt[key](cmt);
        } else {
            elt[key] = cmt;
        }
    }
    var p;
    if (typeof arguments[3] === 'number') {
        p = 4;
    } else {
        p = 3;
        n = str.length;
    }
    if (typeof arguments.length > p) {
        var a = arguments[p++];
        if (typeof a === 'string') {
            typ = a.toLowerCase();
            a = arguments[p++];
            if (isPlainObject(a)) {
                elt = a;
                end = !!arguments[p++];
            } else {
                end = a;
                elt = arguments[p++];
            }
        } else if (isPlainObject(a)) {
            elt = a;
            typ = arguments[p++]||"";
            end = !!arguments[p++];
        }
    }

    var cmt, _inline = false, key = typ||"";

    function getKey(pref, end) {
        var key = pref||"";
        if (key === "comment") {
            key = "";
        }
        if (key) {
            if (end) {
                key += 'End';
            }
        } else {
            if (end) {
                key += 'end';
            }
        }
        if (key) {
            key += "Comment";
        } else {
            key = "comment";
        }
        return key;
    }

    if ((cmt = _processComments(str, i, n))) {
        i = cmt.index;            
        if (key === "comment") {
            key = "";
        }
        if (key === 'outer') {
            if (lastLineNum === cmt.startLineNum) {
                if (opener === ',') {
                    if (cmt.lastLineNum === lineNum && (cmt.object instanceof Comment)) {
                       return {comment: cmt.object, index: i, inline: true};
                    } else {
                         key += 'Inline';
                        _inline = true;                        
                    }
                } else {
                    key += 'Inline';
                    _inline = true;
                }
            }
        } else if (lastLineNum === cmt.startLineNum) {
            if (key === "") {
                key = "inline";
            } else {
                key += 'Inline';
            }            
            _inline = true;
        }
        key = getKey(key, end);
        var clastLineNum = cmt.lastLineNum;
        cmt = cmt.object;
        if (_inline) {
            if (elt instanceof StatementElt || elt instanceof Expression) {
                key = "set" + key[0].toUpperCase() + key.substring(1);
                if (cmt instanceof Comment) {
                    try {
                        elt[key](cmt);
                        cmt = null;
                    } catch (e) {
                        throw e;
                    }
                } else {                                   
                    elt[key](getInlineComment(cmt));                    
                }
            } else {
                if (cmt instanceof Comment) {
                    elt[key] = cmt;
                    cmt = null;
                } else {                                   
                    elt[key] = getInlineComment(cmt);                    
                }
            }
            key = "";
            if (cmt) {
                switch (cmt.size()) {
                    case 0:
                        cmt = null;
                        break;
                    case 1:
                        cmt = cmt.remove(0);
                        break;
                }
            }
        }
        if (cmt) {
            if (!key) {
                key = getKey(typ, end);
            }
            if (typ !==  'outer' && typ !==  'inner') {
                set(elt, key, cmt); 
                if (clastLineNum === lineNum) {
                    //TODO
                }
                cmt = null;
            } else if ((typ ===  'inner' && [ '{', '(', '{' ].indexOf(opener) >= 0 && (i < n && str[i] !== getCloser(opener)) && (clastLineNum  + 1 < lineNum))) {
                set(elt, key, cmt); 
                cmt = null;
            }                
        }
    }
    return {comment: cmt, index: i};
}
function getCloser(opener) {
return { '{': '}', '(' : ')', '[': ']' }[opener]||"";
}
/**
* 
* @param {type} str
* @param {type} i
* @param {type} word
* @param {type} n
* @returns {Boolean}
*/
function isWord(str, i, word, n) {
var end = i + word.length;
return str.startsWith(word, i) 
    && (end === n || (end < n && " \t\n\r\b\v\0(){}[]+-*/%=&|;?,!\\:".indexOf(str[end]) >= 0));
}
/**
* 
* @param {String} str
* @param {unsigned int} i
* @param {unsigned int} n
* @param {type} stmt
* @param {unsigned int} lastLineNum
* @param {unsigned int} lastIndex
* @returns {Object}
*/
function endComment(str, i, n, stmt, lastLineNum, lastIndex) {                
var ctx;
if (isPlainObject(i)) {                    
    ctx = i;
    stmt = i.object;
    lastLineNum = i.lastLineNum;
    i = ctx.index;
} else {
    ctx = { 
        index: i, 
        lastIndex: arguments.length > 5 ? (typeof lastIndex === 'undefined' || lastIndex === null ? i : lastIndex) : i, 
        object: stmt 
    };
    if (arguments.length < 5) {
        lastLineNum = lineNum;
    }
    ctx.lastLineNum = lastLineNum;
}
if (!ctx.comment) {
    var _cmt = processComments(str, lastLineNum, i, n, stmt, 'outer', false);
    ctx.comment = _cmt.comment;
    ctx.index = _cmt.index;
}
return ctx;
}
/**
* 
* @private
* @param {String} str
* @param {type} i
* @param {type} n
* @param {type} stop
* @param {Object} [ctx]
* @returns {Object}
*/
function parseSwitch(str, i, n, stop, ctx) {

    var _cmt, lastIndex;

    i = skipSpaces(str, i, n);

    if (str[i] !== '(') {
        unexpectedChar(str[i], lineNum, getColumn(i), i);
    }
    i = skipSpaces(str, i + 1, n);
    if (!ctx) {
        ctx = {};
    }
    ctx.offset = i;
    ctx.stop = [')'];
    var _switch = new Switch();
    _switch.setExpression(parseExpression(str, ctx));

    // skip ')' and spaces
    i = skipSpaces(str, ctx.index + 1, n);

    if (str[i] !== '{') {
        unexpectedChar(str[i], lineNum, getColumn(i), i);
    }
    i = skipSpaces(str, i + 1, n);

    var defaultCase;

    var CASE = 1, VALUE= 2,BLOCK = 3, STATEMENT = 4, DEFAULT = 5, INIT = 0, 
            step = 0, value, _case, stmt;
    
    while (i < n) {
        if (isWord(str, i, 'case', n)) {
             if (_case) {
                _switch.add(_case);
            }
            i = skipSpaces(str, i + 4, n);
            if ((_cmt = _processComments(str, i, n))) {
                i = _cmt.index;
                //TODO
            }
            step = CASE;
            ctx.offset = i;
            ctx.stop = [':'];
            value = parseExpression(str, ctx);
            if (!(value instanceof Litteral)) {
                throw new Error("Incorrect switch case value at index " + ctx.offset);
            }
            //skip ':' and spaces
            i = skipSpaces(str, ctx.index + 1, n);
            step = VALUE;                        
            _case = new Case();
            _case.setValue(value);

        } else if (isWord(str, i, 'default', n)) {
            if (defaultCase) {
                throw new Error("Incorrect switch : too many default cases");
            }
            if (_case) {
                _switch.add(_case);
            }
            i = skipSpaces(str, i + 7, n);
            if ((_cmt = _processComments(str, i, n))) {
                i = _cmt.index;
                //TODO
            }
            if (str[i] !== ':') {
                throw new Error("Expected ':' and found '" + str[i] + "' at index " + i + "\nLine number: " + lineNum + "\nColumn: " + (getColumn(i)));
            }
            step = DEFAULT;
            i = skipSpaces(str, i + 1, n);
            step = VALUE;                        
            defaultCase = _case = new DefaultCase();
            if ((_cmt = _processComments(str, i, n))) {
                i = _cmt.index;
                //TODO
            }
        } else if (str[i] === '{') {
            if (step !== VALUE && step !== DEFAULT) {
                unexpectedChar(str[i], lineNum, getColumn(i), i);
            }
            stmt = parseBlock(str, i, n, null /* stop */, expressionAsStatement);
            i = skipSpaces(str, stmt.index, n);
            _case.setBody(stmt.object);
            step = BLOCK;
            _switch.add(_case);
            _case = null;
        } else if (str[i] === '}') {
            if (step !== VALUE  && step !== DEFAULT && step !== STATEMENT && step !== BLOCK) {
                throw new Error("Undepected character '}' at index " + i + ":Incorrect switch");
            }
            if (_case instanceof DefaultCase) {
                _switch.setDefault(_case);
            } else if (_case) {
                _switch.add(_case);
            }
            stmt.object = _switch;
            stmt.lastIndex = i + 1;
            stmt.lastLineNum = lineNum;
            //skip '}' and spaces before process following comments
            stmt.index = skipSpaces(str, i + 1, n);
            return stmt;
        } else {
            if (step !== VALUE && step !== DEFAULT && step !== STATEMENT) {
                throw new Error("Incorrect switch case."
                        + "\nLine number: " + lineNum
                        + "\nColumn: " + (getColumn(i)));
            }
            stmt = parseStatement(str, i, n);
            _case.addStatement(stmt.object);
            i = skipSpaces(str, stmt.index, n);
            step = STATEMENT;
        }
    }
    unexpectedEnd();
}
function parseWith(str, i, n, stop, name, start, ctx) {
    //the keyword 'with' already skipped
    var _cmt;
    if (str[i] !== '(') {
        throw new Error("Character '(' expected");                    
    }

    i = skipSpaces(str, i + 1, n);
    if ((_cmt = _processComments(str, i, n))) {

        //TODO
        i = _cmt.index;
        _cmt = _cmt.object;

        //TODO
    }
    var _ctx = { offset: i, stop: [ ')'] };
    var expr = parseExpression(str, _ctx);
    i = skipSpaces(str, _ctx.index + 1, n);
    if ((_cmt = _processComments(str, i, n))) {

        //TODO
        i = _cmt.index;
        _cmt = _cmt.object;

        //TODO

    }
    var stmt;
    if (str[i] === '{') {
        stmt = parseBlock(str, i, n, _cmt, expressionAsStatement);
    } else {
        stmt = parseStatement(str, i, n, [';', unclosedStatementEnd], _cmt);
    }

    stmt.object = new With(expr, stmt.object);
    return stmt;
}
/**
 * 
 * @param {String} str
 * @returns {String}
 */
function keyword(str) {
    return JS_KEYWORDS.indexOf(str) >= 0 ? str : "";
};
/**
* 
* @param {type} str
* @param {type} i
* @param {type} n
* @param {type} stop
* @param {IComment} scmt  The statement comment
* @param {Object} ctx
* @returns {Object}
*/
function parseStatement(str, i, n, stop, scmt, ctx) {
    var _stop;
    if (arguments.length === 0) {
        throw new Error("The string to parse expected");
    }
    if (str instanceof String) {
        str = str.toString();
    } else if (typeof str !== 'string') {
        throw new Error("Incorrect first argument: expected string, found " + (typeof str));
    }
    if (arguments.length === 1) {
        i = 0;
        n = str.length;
    } else if (arguments.length === 3 && typeof arguments[2] !== 'number') {
        stop = arguments[2];
        n = str.length;
    } else if (arguments.length === 5 ) {
        if (!(scmt instanceof IComment || scmt instanceof String || typeof scmt === 'string')) {
            if (isPlainObject(scmt)) {
                if (hasOwnProp(scmt, 'index') || hasOwnProp(scmt, 'stop') || hasOwnProp(scmt, 'offset')) {
                    ctx = scmt;
                    scmt = null;
                }
            } else {
                ctx = null;
                scmt = null;
            }
        }
    }

    if (isPlainObject(i)) {
        ctx = i;
        i = i.index;
        _stop = ctx.stop;
    } else if (!ctx) {
        ctx = {};
    }

    if (!stop) {
        stop = statementEnders;
    }
    if (i instanceof Number) {
        i = n.valueOf();
    }
    if (typeof i !== 'number' || i < 0) {
        i = 0;
    }
    if (n instanceof Number) {
        n = n.valueOf();
    }
    if (typeof n !== 'number' || n < 0) {
        n = str.length;
    }

    i = skipSpaces(str, i||0, n);

    var name, sNameRe = regexps["simple-name"], nameRe = regexps["name"],
        inc = regexps["increment"], 
        match, stmt;

    var cmt = scmt;
    if (!cmt && (_cmt = _processComments(str, i, n))) {
        i = skipSpaces(str, _cmt.index, n);
        cmt = _cmt.object;
        //TODO
    }
    var _cmt, stmt, column = getColumn(i);
    if (str[i] === statementEnder) {
        stmt = {
            object : cmt ? new EmptyStatement(cmt) : new EmptyStatement() , 
            lastIndex : i + 1, 
            index: skipSpaces(str, i + 1, n) 
        };
    } else {
        var lastLineNum;
        if ((match = regexMatch(sNameRe, str, i))) {
            name = match[0];
            var p;
            ctx.lastLineNum = lineNum;
            ctx.lastIndex = sNameRe.lastIndex;
            ctx.start = i; 
            ctx.offset = ctx.index = (p = skipSpaces(str, sNameRe.lastIndex, n)); 
            ctx.stop = stop;
            ctx.comment = null;
            switch(keyword(name)) {
                case "var":
                case "let":
                case "const":
                    if (str.startsWith("var toString = {}.toString;", i)) {
                        console.log("var toString = {}.toString;");
                    }
                    stmt = parseDeclaration(str, p, n, stop, name, ctx);
                    break;
                case "if":
                    stmt = parseIf(str, p, n, stop, ctx);
                    break;
                case "for":
                    stmt = parseFor(str, p, n, stop, ctx);
                    break;
                case "while":
                    stmt = parseWhile(str, p, n, stop, ctx);
                    break;
                case "do":
                    stmt = parseDo(str, p, n, stop, ctx);
                    break;
                case "try":                            
                    stmt = parseTry(str, ctx, n);
                    break;
                case "function":
                    stmt = parseFunctionStatement(str, i, n, stop, "function", true,  null, ctx);  
                    break;
                case "return":
                    stmt = parseReturn(str, ctx, n);
                    break;
                case "throw":
                    stmt = parseThrow(str, p, n, stop, ctx);
                    break;
                case "break":
                    stmt = parseBreak(str, ctx, n);
                    break;
                case "continue":
                    stmt = parseContinue(str, ctx, n);
                    break;
                case "class":
                    stmt = parseClass(str, i, n, stop, ctx);
                    break;
                case "switch":
                    stmt = parseSwitch(str, p, n, stop, ctx);
                    break;
                case "export":
                    stmt = parseExport(str, i, n, ctx);
                    break;
                case "import":
                    stmt = parseImport(str, i, n, ctx);
                    break;
                case "with":
                    stmt = parseWith(str, p, n, stop, name, i, ctx);
                    break;
                case "interface":
                    stmt = parseInterface(str, i, n, stop, ctx);
                    break;
                case "type": 
                    stmt = parseType(str, p, n, stop, ctx);
                    break;
                default:
                    if (str[p] === labelDelim) { //label statement
                        lastLineNum = lineNum;
                        p = skipSpaces(str, p + 1, n);
                        var icmt, ccol;
                        if ((_cmt = _processComments(str, p, n))) {
                            p = _cmt.index;
                            ccol = _cmt.column;
                            _cmt = _cmt.object;
                            if (lastLineNum === _cmt.startLineNum) {
                                if (_cmt instanceof Comment) {
                                    icmt = _cmt;
                                    _cmt = null;
                                } else {
                                    icmt = _cmt.remove(0);
                                }
                            }
                        }

                        if (str[p] === '{') {
                            ctx.index = p;
                            stmt = parseBlock(str, ctx, n, null /* stop */, expressionAsStatement);
                        } else {
                            stmt = parseStatement(str, p, n, stop, _cmt, ctx);
                        }
                        p = skipSpaces(str, stmt.index, n);
                        return { 
                            lastIndex: p,
                            index: p,
                            object: Statement.getInstance({ type: "labeled", label: name, statement: stmt.object, comment: cmt })
                        };
                    } else {
                        stmt = processExpressionStatement(str, i, stop, null, ctx);
                        break;
                    }
            } //end switch
        } else {
            stmt = processExpressionStatement(str, i, stop, null, ctx);                     
        }
    }
    if (typeof _stop !== 'undefined') {
        ctx.stop = _stop;
    }
    if (scmt instanceof String) {
        scmt = scmt.valueOf();
    }
    if (scmt instanceof IComment) {
        stmt.object.setComment(scmt);
    } else if (isPlainObject(scmt)) {
        if (scmt.comment || scmt.inlineComment || scmt.outerInlineComment) {
            if (scmt.comment) {
                stmt.object.setComment(scmt);
            }
            if (scmt.inlineComment) {
                stmt.object.setInlineComment(scmt.inlineComment);
            }
            if (scmt.outerInlineComment) {
                stmt.object.setOuterInlineComment(scmt.outerInlineComment);
            }
        } else {
            stmt.object.setComment(scmt);
        }
    } else if (scmt && typeof scmt === 'string') {
        stmt.object.setComment(scmt);
    }
    stmt.column = column;
    return endComment(str, stmt, n);
}

    
    /**
     * 
     * @param {type} str
     * @param {type} i
     * @param {type} n
     * @param {type} ctx
     * @param {type} stops
     * @returns {ArrayType|SType|UnionType|Func|Class|NamedType}
     */
    function processType(str, i, n, ctx,  stops) {
        if (!stops) {
            stops = [ ',', '}', ')','=', '{'];
        }
        var ch, nameRe = regexps['simple-name'], match, union;
        var ofs = i, types, typ, _array,
            INIT = 0, NAME = 1, LT = 2, GT = 3, DOT = 4, UNION = 5, TYPES = 6, 
            ARRAY = 7, INVOCATION = 8, INDEX = 9, FLAGS = 10, STATEMENT = 11,
            STAR = 12,
            tokens = [], 
            token = {},
            state = INIT, _cmt, lastLineNum = lineNum, lastIndex;
        var typesStops = [ ',', '>'], option = false, flags;
        
        var comments = {}, _cmt, re = regexps["simple-name"];
        if (str[i] === ':') {
            //skip ':', spaces and comments
            _cmt = processComments(str, lineNum, skipSpaces(str, i + 1, n), n, comments, '', false);
            i = _cmt.index;
        }
        if (str[i] === '?') {
            _cmt = processComments(str, lineNum, skipSpaces(str, i + 1, n), n, comments, 'afterOption', false);
            i = _cmt.index;
            option = true;
        };
        
        while (i < n) {
            ch = str[i];
            if (isStop(str, i, stops, lineNum, ctx)) {
                if (state !== NAME && state !== TYPES && state !== ARRAY 
                        && state !== FLAGS && state !== STAR) {
                    unexpectedChar();
                }
                ctx.lastIndex = lastIndex;
                ctx.lastLineNum = lineNum;
                if (!typ) {
                    typ = new SType(tokens);
                }
                if (union) {
                    union[union.length] = typ;
                }
                typ = union ? new UnionType(union) : typ;
                if (flags) {
                    typ.setFlags(flags);
                }
                typ.setOptional(option);
                return typ;
            } else if ((match = regexMatch(nameRe, str, i))) {                
                lastLineNum = lineNum;
                lastIndex = i = nameRe.lastIndex;
                match = match[0];
                _cmt = processComments(str, lastLineNum, skipSpaces(str, i , n), n, token, '', /* end comment */ true);
                i = _cmt.index;
                if (['function', 'class', 'type'].indexOf(match) >= 0 && tokens.length === 0) {
                    if (match === 'function') {
                        
                    } else if (match === 'class') {
                        
                    } else if (match === 'type') {
                        
                    }
                } else {
                    token.symbol =  match;
                    tokens[tokens.length] = token;
                    state = NAME;                    
                }
            } else if (ch === '|') {
                if (state !== NAME && state !== TYPES && state !== ARRAY && state !== STATEMENT) {
                    //throw unexpected character exception
                    unexpectedChar(ch, lineNum, i - lineOffset + 1, i);
                }
                if (!union) {
                    union = [];
                }
                if (typ) {
                    union[union.length] = typ;
                    typ = null;
                } else {
                    union[union.length] = new SType(tokens);                    
                }
                state = UNION;
                tokens = [];
                token = {};
                lastLineNum = lineNum; 
                _cmt = processComments(str, lastLineNum, skipSpaces(str, i + 1 , n), n, token, '', /* not end comment */ false);
                i = _cmt.index;
            } else if (ch === '<') {
                if (state !== NAME) {
                    unexpectedChar();
                }
                types = processTypes(str, i, n, ctx, typesStops);
                lastLineNum = ctx.lastLineNum;
                lastIndex = i = ctx.index;
                state = TYPES;
                typ = new SType(tokens, types);
                _cmt = processComments(str, lastLineNum, skipSpaces(str, i , n), n, typ, '', /* end comment */ true);
                i = _cmt.index;
                tokens = [];
                token = {};
            } else if (ch === '.') {
                if (state !== NAME && state !== INVOCATION && state !== INDEX && state !== STATEMENT) {
                    unexpectedChar();
                }
                token = {};
                if (state !== NAME) {
                    tokens = [];
                }
                lastLineNum = lineNum; 
                _cmt = processComments(str, lastLineNum, skipSpaces(str, i + 1 , n), n, token, '', /* not end comment */ false);
                i = _cmt.index;
                state = DOT;
            }  else if (ch === '[') {
                if (state !== NAME && state !== ARRAY && state !== TYPES  && state !== STATEMENT) {
                    unexpectedChar();
                }              
                var acmt = _cmt.comment;
                _cmt = processComments(str, lastLineNum, skipSpaces(str, i + 1 , n), n, _array, 'inner', /* not end comment */ false);
                i = _cmt.index;
                if (str[i] === ']') {
                    _array = {};
                    if (acmt) {
                        _array.comment = acmt;
                    }
                    if (_cmt.comment) {
                        _array.innerComment = _cmt.comment;
                        _cmt.comment = null;
                    }
                    if (!typ) {
                        typ = new SType(tokens);
                        var arr = new ArrayType();
                        arr._type = typ;
                        typ = arr;
                        tokens = [];
                        token = {};
                    }                
                    _cmt = processComments(str, lastLineNum, skipSpaces(str, i + 1 , n), n, _array, '', /* end comment */ true);
                    typ.addDimension(_array);
                    i = _cmt.index;
                    state = ARRAY;
                } else {
                    unexpectedChar();
                }
                
            } else if (ch === '%') {
                flags = parseFlags(str, i, n, ctx);
                state = FLAGS;
                i = ctx.index;
            }  else if (ch === '(') {
                var _arrowOrGrp = arrowFuncOrGrouping(str, i, n);                
                if (_arrowOrGrp) {
                    var stop = [ '{', '(', ',', '|'];
                    if (_arrowOrGrp.arrow) {
                        _arrowOrGrp.stop = stop;
                        _arrowOrGrp.offset = _arrowOrGrp.index;
                        typ = processArrowFunc(str, n, _arrowOrGrp, _arrowOrGrp, stop, i, true);
                        state = STATEMENT;
                        _arrowOrGrp.arrow = false;
                        i = typ.index;
                        _cmt = typ.comment;
                        typ = typ.object;
                    } else {
                        unexpectedChar();
                    }
                } else {
                    unexpectedChar();
                }
            } else if (ch === '*') {
                token.symbol = '*';
                tokens[tokens.length] = token;
                _cmt = processComments(str, lastLineNum, skipSpaces(str, i + 1 , n), n, typ, '', /* end comment */ true);
                state = STAR;
                i = _cmt.index;
            } else {
                unexpectedChar();
            }
        }
        unexpectedEnd();
    }
    
    function parseFlags(str, i, n, ctx) {
        
        var ch, match, re = regexps['simple-name'], flags = {}, flag;
        while (i < n) {
            ch = str[i];
            if (ch === '%') {
                //skip '%' character
                i++;
            } else if ((match = regexMatch(re, str, i))) {
                flag = match[0];
                if (typeof flags[flag] !== 'undefined') {
                    throw new Error("Too many flags: '" + flag + "'");
                }
                flags[flag] = true;
                i = skipSpaces(str, re.lastIndex, n); 
            } else {
                ctx.index = i;
                return flags;
            }
        }
    }
    function processTypes(str, i, n, ctx, stops) {
        if (!stops) {
            stops = [ ',', '>'];
        }
        var types = [];
        if (str.startsWith('<*>', i)) {
            console.log('<*>');
        }
        //skip character '<' and spaces
        i = skipSpaces(str, i + 1, n);        
        
        
        while (i < n) {
            ctx.index = i;
            types[types.length] = processType(str, i, n, ctx, stops);
            i = ctx.index;
            if (str[i] === ',') {
                //skip character ',' and spaces
                i = skipSpaces(str, i + 1, n);
            } else if (str[i] === '>') {
                //skip character '>' and spaces
                ctx.index = skipSpaces(str, i + 1, n);
                return types;
            } else {
                unexpectedChar();
            }
        }
    }
    function processNamedTypes(str, i, n, ctx, stops) {
        if (!stops) {
            stops = [ ',', '>'];
        }
        var types = [], nameRe = regexps['simple-name'], name;
        //skip character '<' and spaces
        i = skipSpaces(str, i + 1, n);        
        
        
        while (i < n) {
            if (!(name = regexMatch(nameRe, str, i, n))) {
                throw new Error("Expected name");
            }
            name = name[0];
            ctx.index = i = nameRe.lastIndex;
            types[types.length] = new NParamType(name, processType(str, i, n, ctx, stops));
            i = ctx.index;
            if (str[i] === ',') {
                //skip character ',' and spaces
                i = skipSpaces(str, i + 1, n);
            } else if (str[i] === '>') {
                ctx.lastIndex = i + 1;
                ctx.lastLineNum = lineNum;
                //skip character '>' and spaces
                ctx.index = skipSpaces(str, i + 1, n);
                return new NParamTypes(types);
            } else {
                unexpectedChar();
            }
        }
    }
/**
 * 
 * @param {type} str
 * @param {type} i
 * @param {type} n
 * @param {type} stop
 * @param {type} ctx
 * @returns {NamedType}
 */
function parseType(str, i, n, stop, ctx) {
    //'type' keyword already skipped
    
    function end() {
        struct.fields = entries;
        obj.structure = struct;
        if (_cmt) {
            obj.endComment = _cmt;
        }
        lastLineNum = lineNum;
        ctx.lastIndex = i + 1;
        // skip character '}' and spaces
        _cmt = processComments(str, lastLineNum, skipSpaces(str, i + 1, n), n, obj, 'outer', false);
        ctx.index = _cmt.index;
        ctx.object = new NamedType(obj);
        ctx.stop = stop;
        ctx.start = start;
        ctx.comment = _cmt.comment;
        isStop(str, ctx);
        return endStatement(str, ctx);
    }
    var keyRe = regexps.key,
            key, match, 
            entry,
            entries = [],
            start = i,
            lastLineNum = ctx.lastLineNum,
            _cmt;
    
    ctx.stop =  [entryCloser, '}'];
    var obj = {}, _cmt;
    _cmt = processComments(str, lastLineNum, skipSpaces(str, i, n), n, obj, 'beforeName', false);
    i = _cmt.index;
    if (!(match = regexMatch(keyRe, str, i))) {
        unexpectedChar(str[i], lineNum, getColumn(i), i);
    }
    obj.name = match[0];    
    lastLineNum = lineNum;
    _cmt = processComments(str, lastLineNum, skipSpaces(str, keyRe.lastIndex, n), n, obj, 'afterName', false);
    i = _cmt.index;
    if (i >= n) {
        unexpectedEnd(); //throw exception
    }
    if (str[i] !== '=') {
        unexpectedChar(str[i], lineNum, getColumn(i), i);
    }
    var struct = {};
    // skip character '=' and spaces and process comments
    _cmt = processComments(str, lineNum, skipSpaces(str, i + 1, n), n, struct, '', false);
    i = _cmt.index;
    
    
    
    if (i >= n) {
        unexpectedEnd(); //throw exception
    }
    if (str[i] !== '{') {
        unexpectedChar(str[i], lineNum, getColumn(i), i);
    }
    // skip character '{' and spaces and process comments
    _cmt = processComments(str, lineNum, skipSpaces(str, i + 1, n), n, struct, 'inner', false);
    i = _cmt.index;
    _cmt = _cmt.comment;
    if (i < n && str[i] === '}') {
        return end();
    }
    var qkey, typeComments = {}, entry, entries = [], typ, option;
    while (i < n) {
        if ((match = regexMatch(keyRe, str, i))) {
            key = match[0];
            if (key[0] === "'" || key[0] === '"') {
                qkey = QString.getInstance(key);
                key = qkey.getValue();
            } else if (notKeywordKey && keywords.indexOf(key) >= 0) {
                throw new Error("Key can not be a keyword: '" + key + "'");
            } else {
                qkey = new VString(key);
            }
            if (_cmt) {
                qkey.setComment(_cmt);
            }
            lastLineNum = lineNum;
            i = skipSpaces(str, keyRe.lastIndex, n);
            if (i >= n) {
                unexpectedEnd();
            }
            _cmt = processComments(str, lastLineNum, i, n, qkey, '', true);
            i = _cmt.index;
            _cmt = _cmt.comment;
            if (!str.startsWith(keyDelim, i)) {
                unexpectedChar(str[i], lineNum, getColumn(i), i);
            }
            lastLineNum = lineNum;
            ctx.offset = i = skipSpaces(str, i + keyDelim.length, n);
            _cmt = processTempComments(str, lastLineNum, i, n, typeComments, '', true);
            ctx.index = i = _cmt.index;
            if (str[i] === '?') {
                option = true;
                ctx.index = ++i;
            } else {
                option = false;
            }
            if ((typ = processType(str, i, n, ctx))) {
                setComments(typ, typeComments);
                if (_cmt) {
                    //TODO : 
                }
                entry = {name :  qkey, type: typ, option: option};
                entries[entries.length] = entry;
                i = ctx.index;
                _cmt = ctx.comment;
                //TODO: peocess or set above _cmt
                //
                //
                //by default the entry closer is ','
                if (str.startsWith(entryCloser, ctx.index)) {
                    lastLineNum = lineNum;
                    // skip entry stop ',' for example
                    i = skipSpaces(str, i + entryCloser.length, n);
                    _cmt = processComments(str, lastLineNum, i, n, entry, 'outer', false);
                     i = ctx.index = _cmt.index;
                    _cmt = ctx.comment;
                    if (str.startsWith('}', i)) {
                        return end();
                    }
                } else if (str.startsWith('}', ctx.index)) {
                    return end();
                } else {
                    //throw "Unepected character" exception
                    unexpectedChar(str[ctx.index], lineNum, ctx.index - lineOffset + 1, ctx.index, "Unexpected character: epecting ',' or '}'");
                }
            } else {
                throw new Error("Incorrect object expression");
            }
        } else {
            throw new Error("Incorrect object expression. Expected object key/name, found character '" + str[i] + "'" );
        }
    }
    unexpectedEnd();
}
/**
* 
* @param {type} str
* @param {type} i
* @param {type} stop
* @param {IComment} cmt
* @returns {Object}
*/
function processExpressionStatement(str, i, stop, cmt, chain, _ctx) {
    if (!(arguments[4] instanceof ChainedStatements)) {            
        if (isPlainObject(arguments[4])) {
            _ctx = arguments[4];
        }
        chain = null;
    }
    if (!_ctx && isPlainObject(i)) {
        _ctx = i;
    }
    var p, s ;
    if ([ '[', '{'].indexOf(str[p = isPlainObject(i) ? i.index : i]) >= 0) {
        if (isPlainObject(i)) {
            if (!cmt)
                cmt = i.comment;
        }
        if (str[p] === '[' || str.startsWith("?[", p)) {
            _ctx = processArray(str, p, str.length, "", _ctx) //parseArrayDestructuring(str, p, str.length, "", _ctx);
        } else {
            _ctx = parseObjectDestructuring(str, p, str.length, "", _ctx);
        }
        s = _ctx.object;
    } else {
        var _stop ;
        if (isPlainObject(i)) {                    
            i.offset = i.index;
            i.lastLineNum = lineNum;                    
            chain = arguments[2];
            stop = isArray(arguments[4])? arguments[4] : i.stop;
            if (arguments.length > 4 && arguments[4]) {
                if (statementChainSymbol && stop.indexOf(statementChainSymbol) < 0) {
                    _stop = stop.slice();
                    _stop[_stop.length] = statementChainSymbol;
                } else {
                    _stop = stop;
                }
                i.stop = _stop;
            }
            if (!cmt) {
                cmt = i.comment;
            }
            _ctx = i;
            i = i.index;
        } else {
            if (_ctx) {
                _ctx.offset = i;
                _ctx.lastLineNum = lineNum;
            } else {
                _ctx = { offset: i, lastLineNum: lineNum};
            }
            if (statementChainSymbol && stop.indexOf(statementChainSymbol) < 0) {
                _stop = stop.slice();
                _stop[_stop.length] = statementChainSymbol;
            } else {
                _stop = stop;
            }
            _ctx.stop = _stop;
        }


        var lastLineNum = lineNum,  
                column = getColumn(i);
        try {
            if (lineNum > 10000) {
                console.log("line number: " + lineNum);
            }
            if (str.startsWith("ofs = ++i;", _ctx.offset)) {
                console.log("ofs = ++i;" + lineNum);
            }
            s = parseExpression(str, _ctx);  
        } catch (e) {
            throw e;
        }
        if ((s instanceof QString) && getQuotedHintStatement(s)) {
            s = new QuotedHintStatement(s);
        } else {
            try {
                Statement.getInstance(s, expressionAsStatement);
            } catch(e) {
                var msg = "Statement expected but expression found";
                msg += " alt line " + lastLineNum + ", column " + column + " and index " + i;
                throw new Error(msg, e);
            }
        }
        _ctx.object = s;

    }
    
    if (isPlainObject(cmt)&& isPlainObject(cmt.comment)) {
        if (cmt.inline) {
            s.setInlineComment(cmt);
        } else {
            s.setComment(cmt);
        }
    } else if (cmt instanceof IComment) {
        s.setComment(cmt);
    }




    if ((i = _ctx.index) < str.length &&  statementChainSymbol === str[i]) {
        if (!chain) {
            chain = new ChainedStatements();
        }
        var n = str.length, 
            c = processComments(str, lineNum, i = skipSpaces(str, i + statementChainSymbol.length, str.length), n, s, 'outer', false, statementChainSymbol);
        _ctx.index = c.index;
        chain.add(s);
        _ctx.ender = null;
        return processExpressionStatement(str, _ctx, chain, c);
    }
    if (_ctx.object instanceof LROperation) {
        var right = _ctx.object.getRight();
        if (right instanceof AnonymousFunction 
                || right instanceof NamedFunction 
                || (right instanceof ArrowFunction && right.getBody() instanceof Block)
                || right instanceof Class) {
            var e;
            if (!(e = isStop(str, i, _ctx.stop, _ctx.lastLineNum))) {
                throw new Error("End statement symbol expected");
            }
            _ctx.ender = e.ender;
            _ctx.lastIndex = i + e.lastIndex;
            _ctx.index = e.index;                        
        }
    }
    s = endStatement(str, _ctx, i);
    if (chain) {
        chain.add(s.object);
        s.object = chain;
        return s;
    }
    return s;
}
/**
* 
* @private
* @param {String} str
* @param {Number|Object} i
* @param {type} n
* @param {IComment} cmt
* @param {Array|Function} [stop]
* @param {Boolean} [exprAsStatement=expressionAsStatement]
* @returns {Object}
* @todo Normalize this function with only i as context  Object not number and apply it everywhere this function is called
*/
function parseBlock(str, i, n, cmt, stop, exprAsStatement) {
var ctx;
if (typeof i === 'object' && (typeof arguments[2]) === 'boolean' ) {
    exprAsStatement = arguments[2];
    cmt = stop = null;
    n = str.length;
} else if (arguments.length > 3 && typeof arguments[3] === 'boolean') {
    exprAsStatement = arguments[3];
    if (arguments[4] instanceof IComment) {
        cmt = arguments[4];
        if (isPlainObject(arguments[4])) {
            ctx = arguments[4];
        }
        stop = null;
    } else {
        if (isPlainObject(arguments[4])) {
            ctx = arguments[4];
        }
        cmt = stop = null;
    }
} else if (arguments.length > 3 && arguments[3] instanceof IComment) {
    cmt = arguments[3];
    if (typeof arguments[4] === 'boolean') {
        exprAsStatement = arguments[4];
        if (isPlainObject(arguments[5])) {
            ctx = arguments[5];
        }
    }
    stop = null;
} else if (arguments.length > 4 && typeof arguments[4] === 'boolean') {
    exprAsStatement = arguments[4];
    if (isArray(arguments[3]) || typeof arguments[3] === 'function') {
        if (isPlainObject(arguments[5])) {
            ctx = arguments[5];
        }
        stop = arguments[3];
        cmt = null;
    } else {
        if (isPlainObject(arguments[5])) {
            ctx = arguments[5];
        }
        stop = null;
    }

}

if (typeof exprAsStatement === 'undefined') {
    exprAsStatement = expressionAsStatement;
}

var startLineNum = lineNum, 
    start = i,
    lastLineNum //statement last line number
;

if (typeof i === 'object') {
    if (!ctx) {
        ctx = i;
    }
    stop = i.stop;
    i = i.index||i.offset||0;
} else if (!ctx) {
    ctx = {};
}
var statements = [], 
        stop = statementEnders, 
        stmt, 
        _cmt = null;

//skip character '{' and spaces
i = skipSpaces(str, i + 1, n);

while (i < n) {
    if (!_cmt && (_cmt = _processComments(str, i, n))) {
        i = skipSpaces(str, _cmt.index, n);
        _cmt = _cmt.object;
        if (stmt && stmt.lastLineNum === _cmt.startLineNum) {
            if (_cmt.object instanceof Comment) {
                stmt.setInlineComment(_cmt);
                _cmt = null;
            } else {
                stmt.setInlineComment(_cmt.remove(0));
            }
        }
    } else if (str[i] === '}') {
        var b = {
            statements :  statements, 
            comment: cmt, 
            endComment: _cmt 
        };
        var lastIndex = i + 1; 
        lastLineNum = lineNum;
        _cmt = processComments(str, lineNum, skipSpaces(str, i + 1, n), n, b, 'outer', false);
        ctx.ender = null;
        return getContext(ctx, _cmt.index, lastIndex, exprAsStatement ? new Block(b, true) : new SBlock(b), lastLineNum, _cmt.comment);
    } else {
        stmt = parseStatement(str, i, n, stop, _cmt, ctx);
        statements[statements.length] = stmt.object;
        _cmt = stmt.comment;
        stmt.comment = null;
        i = stmt.index;
    }
}
unexpectedEnd();
}
/**
* 
* @private
* @param {String} str  The tring to parse
* @param {unsigned int} i  The parse offset index
* @param {unsigned int} n  The length of the string or ubstring to parse
* @param {Array} stop
* @param {String} keyword Keyword already parsed
* @param {IComment} cmt
* @returns {Object}
*/
function parseAsyncFunction(str, i, n, stop, keyword, cmt, ctx) {
    if (arguments.length === 6) {
        if (!(cmt instanceof IComment)) {
            if (typeof cmt === 'string' || cmt instanceof String) {
                cmt = IComment.getInstance(cmt);
            } else {
                if (isPlainObject(cmt)) {
                    ctx = cmt;
                }
                cmt = null;
            }
        }
    }
    var lastLineNum = lineNum, comments = {};
    //skip the keyword
    i = skipSpaces(str, i + (keyword||"async").length, n);
    var acmt = processComments(str, lastLineNum, skipSpaces(str, i + 1, n), n, comments, 'async', false);
    //the 'function' keyword regular expression
    var re = regexps["function"]; 
    // if the 'function' keyword not at the position/index i of the string to process
    if (regexMatch(re, str, i)) {                    
        var result =  parseFunction(str, i, n, stop, 'function', false, cmt, ctx);
        result.object.setAsync(true);
        return result;                    
    }
    var match, _arrowOrGrp = {};
    if ((match = arrowFuncOrGrouping(str, i, n, _arrowOrGrp)) && match.arrow) {
        _arrowOrGrp.stop = stop;
        _arrowOrGrp.offset = match.index;
        var f = processArrowFunc(str, n, match, _arrowOrGrp, stop, i);
        f.object.setAsync(true);
        return f;
    }
    throw new Error("Keyword 'function' or character '(' expected. Found character '"+ str[i] + "' at line " + lineNum + ", column " + getColumn(i) + " and index " + i);
}
/**
* 
* @param {type} str
* @param {type} i
* @param {type} n
* @param {type} _static
* @param {type} _cmt
* @param {String} prefix
* @returns {Object}
*/
function parseComputedNameMethod(str, i, n, _static, _cmt, prefix) {
    //skip character '[' and spaces
    i = skipSpaces(str, i + 1, n);
    var _ctx = { offset: i, stop: [']'] }, col, lastLineNum;
    var name  = parseExpression(str, _ctx);
    col = getColumn(_ctx.index);
    lastLineNum = lineNum;
    //skip character ']' and spaces
    if (prefix) {
        name = [ prefix, name];
    }
    i = skipSpaces(str, _ctx.index + 1, n);
    if (i < n && str[i] !== '(') {
        if (!isArray(name)) {
            name = [ name ];
        }
        if (i > _ctx.index + 1) {
            throw new Error("Expected character '{', found '" + str[_ctx.index + 1] + "'"
                + " at line " + lastLineNum + ", column " + (col + 1) + " and index " + i);
        }
        var nameRe = regexps['simple-name'], match, expr = true;
        while (i < n && str[i] !== '(') {
            if (expr) {
                if (!(match = regexMatch(nameRe, str, i))) {
                    throw new Error("Expected name");
                } else {
                    name[name.length] = match[0];
                }
                expr = false;
                i = nameRe.lastIndex;
            } else {
                _ctx.offset = i;
                name[name.length]  = parseExpression(str, _ctx);
                i = _ctx.index;
                expr = true;
            }
        }
    }
    name = isArray(name) ? new ComputedName(name) : new EComputedName(name);

    var params = parseParams(str, i, n);                        
    i = params.index;
    var lastLineNum = params.lastLineNum;
    params = params.object;
    _cmt = params.comment;
    var returnType, ctx= {};
    if (str[i] === ':') {
        returnType = processType(str, i, n, ctx, ['{']);
        i = ctx.index;        
    }
    if (str[i] !== '{') {
        throw new Error("Expected character '{', found '" + str[i] + "'"
                + " at line " + lineNum + ", column " + (getColumn(i)) + " and index " + i);
    }
    var s = parseBlock(str, i, n, _cmt, expressionAsStatement, ctx);
    _cmt = s.comment;
    i = s.index;
    s.object = new CNMethod(name, params, s.object);
    if (_static) {
        s.object.setStatic(_static);
    }
    if (returnType) {
        s.object.setReturnType(returnType);
    }
    return s;
}
/**
* Parses class the from the given current position in the given text.
* @private
* @param {String} str  The text to parse
* @param {unsigned int} i  The current position (index) into the text to parse
* @param {unsigned int} n  The length of the text to parse
* @param {IComment} cmt  The comment of the class
* @param {Array} stop 
* @param {Object} ctx
* @returns {Object}
* @throws {Error} 
*/
function parseClass(str, i, n, cmt, stop, ctx) {
    if (isArray(arguments[3])) {
        var s = arguments[3];
        var a = arguments[4];
        if (a instanceof IComment || a.comment ||a.inlineComment) {
            cmt = a;
        } else {
            a = arguments[5];
            ctx = arguments[4];
            cmt = a instanceof IComment || isPlainObject(a) ? a : null;
        }
        stop = s;
    }
    var expression = false;
    if (isPlainObject(i)) {
        ctx = i;
        expression = i.expression||false;
        i.expression = false;
        i = i.offset;
    }
    var lastLineNum = lineNum, start = i;
    //skip 'class' and spaces;
    i = skipSpaces(str, i + 5, n);
    
    var cname, snameRe = regexps['simple-name'];
    if (!(cname = regexMatch(snameRe, str, i))) {
        if (!expression)
            throw new Error("Expected name, found '" + str[i] + "'");
        cname = "";
    } else {
        cname = cname[0];
        i = snameRe.lastIndex;
    }
    
    var comments = {}, _types;
    
    function parseImplements(impl) {        
        if (impl) {
            i += impl.length;
        } else {
            var snameRe = regexps['simple-name'];
            if (!(impl = regexMatch(snameRe, str, i))) {
                return false;
            }
            impl = impl[0];
            i = snameRe.lastIndex;
        }
        if (impl !== 'implements') {
            throw new Error("Keyword 'implements' expected, found '" + impl[0] + "'");
        }
        lastLineNum = lineNum;
        var comments, typ;        
        impl = [];
        while (i < n) {
            comments = {};
            _cmt = processComments(str, lastLineNum, skipSpaces(str, i, n), n, comments, '', false);
            i = _cmt.index;
            typ = processType(str, i, n, ctx, [',', '{']);
            if (typ instanceof Func || typ instanceof Class || typ instanceof NamedType) {
                throw new Error("Unexpected Function, Class or NamedType object"); 
            }
            if (comments.comment) {
                typ.setComment(comments.comment);
            }
            if (comments.inlineComment) {
                typ.setInlineComment(comments.inlineComment);
            }
            impl[impl.length] = typ;
            i = ctx.index;
            if (str[i] === '{') {
                return impl;
            }
            lastLineNum = lineNum;
            i = i + 1;
        }
        unexpectedEnd();
    }
    lastLineNum = lineNum;
    //skip spaces and process comments
    _cmt = processComments(str, lastLineNum, skipSpaces(str, i, n), n, comments, '', false);
    i = _cmt.index;  
    if (str[i] === '<') {
        _types = processNamedTypes(str, i, n, ctx);
        if (comments.comment) {
            _types.setComment(comments.comment);
        }
        if (comments.inlineComment) {
            _types.setInlineComment(comments.inlineComment);
        }
        i = ctx.index;
        //skip spaces and process comments
        _cmt = processComments(str, ctx.lastLineNum, i, n, _types, 'outer', false);
        i = _cmt.index;
    }

    var ext, impl;
    if ((ext = regexMatch(snameRe, str, i))) {
        ext = ext[0];
        if (ext === 'extends') {
            i = skipSpaces(str, snameRe.lastIndex, n);
            if (!(ext = regexMatch(snameRe, str, i))) {
                throw new Error("Expected keyword super class name, found '" + str[i] + "'"
                        + " at line " + lineNum + ", column " + (getColumn(i)) + " and index " + i);
            }
            ext = ext[0];
            i = skipSpaces(str, snameRe.lastIndex, n);
        } else {
            impl = ext;
            ext = null;
        }
    }
    impl = parseImplements(impl, i);
    
    if (str[i] !== '{') {
        throw new Error("Expected character '{', found '" + str[i] + "'"
                + " at line " + lineNum + ", column " + (getColumn(i)) + " and index " + i);
    }
    lastLineNum = lineNum;
    var name, 
        _async = false,
        _static,
        _private,
        generator = false,
        params, 
        elts = [],
        _cmt, accessor,
        dStop, 
        e, 
        _ctx, 
        key;

    var names = [];
    var icmt, method;
    //skip character '{' and spaces
    i = skipSpaces(str, i + 1, n);
    if ((_cmt = _processComments(str, i, n))) {
        i = _cmt.index;                    
        if (lastLineNum === _cmt.startLineNum) {
            _cmt = _cmt.object;
            if (_cmt instanceof Comment) {
                icmt = _cmt;
                _cmt = null;
            } else {
                icmt = _cmt.remove(0);
            }
        } else {
            _cmt = _cmt.object;
        }
    }
    var startLineNum, lastIndex, type;
    var _async = false, comments = {};
    
    function processName() {
        generator = false;
        if (str[i] === '[') {
            method = parseComputedNameMethod(str, i, n, false, _cmt);
            e = method.object;
            i = method.index;
            _private = false;

        } else if (str[i] === '#') {
            if (!(name = regexMatch(snameRe, str, ++i))) {
                throw new Error("Expected name or 'static' keyword, found '" + str[i] + "'");
            }
            name = name[0];
            if (name === 'static') {
                throw new Error("Expected name, found 'static'");
            }
            _private = true;
            _static = false;            
        } else {
            if (str[i] === '*') {
                i++;
                generator = true;
            }
            if (!(name = regexMatch(snameRe, str, i))) {
                throw new Error("Expected name or 'static' keyword, found '" + str[i] + "'");
            } else {
                _private = false;
                _static = false;
                name = name[0];
            }
        }

        if (name === 'static') {
            _static = true;
            _private = false;
            lastLineNum = lineNum;
            lastIndex = snameRe.lastIndex;
            i = skipSpaces(str, lastIndex, n);
            _cmt = processComments(str, lastLineNum, i, n, comments, 'afterStatic', false);
            i = _cmt.index;
            _cmt = _cmt.comment;
            
            if (str[i] === '[') {
                method = parseComputedNameMethod(str, i, n, true, _cmt);
                e = method.object;
                i = method.index;
                name = null;
            } else {
                if (str[i] === '#') {
                    if (!(name = regexMatch(snameRe, str, ++i))) {
                        throw new Error("Expected name or 'static' keyword, found '" + str[i] + "'");
                    }
                    _private = true;
                } else if (!(name = regexMatch(snameRe, str, i))) {
                    throw new Error("Expected name , found '" + str[i] + "'");
                }
                name = name[0];
                if (name === 'constructor') {
                    throw new Error("Expected name , found '" + name + "'");
                } else if (name === 'async') {
                    if (_private) {
                        throw new Error("Expected name , found 'async' keyword");
                    }
                    _async = true;
                    lastLineNum = lineNum;
                    lastIndex = snameRe.lastIndex;
                    i = skipSpaces(str, lastIndex, n);
                    _cmt = processComments(str, lastLineNum, i, n, comments, 'afterAsync', false);
                    i = _cmt.index;
                    _cmt = _cmt.comment;
                    if (!(name = regexMatch(snameRe, str, i))) {
                        throw new Error("Expected name , found '" + str[i] + "'");
                    }
                    name = name[0];
                }
                lastLineNum = lineNum;
                lastIndex = snameRe.lastIndex;
                i = skipSpaces(str, lastIndex, n);
                _cmt = processComments(str, lastLineNum, i, n, comments, 'afterName', false);
                i = _cmt.index;
                _cmt = _cmt.comment;
            }
        } else if (name) {
            if (name === 'async') {
                _async = true;
                name = null;
            }
            lastLineNum = lineNum;
            lastIndex = snameRe.lastIndex;
            i = skipSpaces(str, lastIndex, n);
            if (i >= n) {
                unexpectedEnd();
            }
            _cmt = processComments(str, lastLineNum, i, n, comments, _async ? 'afterAsync' : '', true);
            i = _cmt.index;
            _cmt = _cmt.comment;
            if (str[i] === '[') {
                method = parseComputedNameMethod(str, i, n, false, _cmt, name);
                e = method.object;
                i = method.index;
                e.async = _async;
                name = null;
            } else {
                if (!(name = regexMatch(snameRe, str, i))) {
                    throw new Error("Expected name, found '" + str[i] + "'");
                }
                name = name[0];
                lastLineNum = lineNum;
                lastIndex = snameRe.lastIndex;
                i = skipSpaces(str, lastIndex, n);
                _cmt = processComments(str, lastLineNum, i, n, comments, '', true);
                i = _cmt.index;
                _cmt = _cmt.comment;
                if (str[i] === '[') {
                    method = parseComputedNameMethod(str, i, n, false, _cmt, name);
                    e = method.object;
                    i = method.index;
                    e.async = _async;
                    name = null;
                }
            }
        }
        return name;
    }

    function initAccessor() {
        if (str[i] === '*') {
            //Throw exception
            unexpectedChar('*', lineNum, getColumn(i), i); 
        }
        var match;
        if (!(match = regexMatch(snameRe, str, i))) {
            if (str[i] === ':') {
                key = name;
                return false;
            }
            throw new Error("Expected name or 'static' keyword, found '" + str[i] + "'");
        } else {
            accessor = name;
            name = match[0];
        }
        if (name === 'constructor') {
            throw new Error("Expected name , found '" + name + "'");
        }
        i = skipSpaces(str, snameRe.lastIndex, n);   
        if ((_cmt = _processComments(str, i, n))) {
            i = _cmt.index;
            //TODO
        }
        if (str[i] !== '(') {
            throw new Error("Expected character '{', found '"+ str[i] + "'"
                + " at line " + lineNum + ", column " + (getColumn(i)) + " and index " + i);
        }
        key = name + "[[" + accessor + "]]";
        if (names.indexOf(name + "[[" + (accessor === 'get' ? 'set' : 'get') + "]]") < 0) {
            names[names.length] = name;
        }
    }
    function processValuedField() {
        if (name === 'constructor' || accessor) {
            throw new Error("Expected name , found '" + str[i] + "'");
        }
        i = skipSpaces(str, i + 1, n);
        if ((_cmt = _processComments(str, i, n))) {
            i = _cmt.index;
            //TODO
        }
        _ctx = { offset : i, stop: statementEnders};
        e = parseExpression(str, _ctx);
        if (_cmt) {
            e.setComment(_cmt);
        }
        e = new Field(name, e);
        if (type) {
            e.setType(type);
        }
        i = _ctx.index;
        lastLineNum = _ctx.lastLineNum;                      
        _ctx = endStatement(str, _ctx);
        i = _ctx.index;
        if (_ctx.ender) {
            _cmt = endComment(str, i, n, e, _ctx.lastLineNum, _ctx.lastIndex);
            i = _cmt.index;
            _cmt = _cmt.comment;
        } else {
            _cmt = _ctx.comment;
        }
    }
    function processCallable() {
        var comments = {}, _types;
        _cmt = _cmt = processComments(str, lastLineNum, skipSpaces(str, i, n), n, comments, '', false);
        i = _cmt.index;
        _cmt = _cmt.comment;
        if (str[i] === '<') {
            _types = processNamedTypes(str, i, n, ctx);
            if (comments.comment) {
                _types.setComment(comments.comment);
            }
            if (comments.inlineComment) {
                _types.setInlineComment(comments.inlineComment);
            }
            comments = null;
            i = ctx.index;
            //skip spaces and process comments
            _cmt = processComments(str, ctx.lastLineNum, i, n, _types, 'outer', false);
            i = _cmt.index;
            _cmt = _cmt.comment;
        }
        params = parseParams(str, i, n);  
        if (_cmt) {
            params.object.setComment(_cmt);
        }
        i = params.index;
        lastLineNum = params.lastLineNum;
        _cmt = params.comment;
        params = params.object;
        if (comments) {
            if (comments.comment) {
                params.setComment(comments.comment);
            }

            if (comments.inlineComment) {
                params.setInlineComment(comments.inlineComment);
            }
        }
        
        var returnType, ctx= {};
        if (str[i] === ':') {
            returnType = processType(str, i, n, ctx, ['{']);
            i = ctx.index;        
        }
        if (str[i] !== '{') {
            throw new Error("Expected character '{', found '" + str[i] + "'"
                    + " at line " + lineNum + ", column " + (getColumn(i)) + " and index " + i);
        }
        var body = parseBlock(str, i, n, _cmt, expressionAsStatement, ctx);
        _cmt = body.comment;
        i = body.index;
        body = body.object;
        e = accessor === 'get' ? 
            new Getter(name, params, body): accessor === 'set' ? 
                new Setter(name, params, body) : 
                    name === 'constructor' ? 
                        new Constructor(params, body) : 
                                new Method(name, params, body);
        if (_static) {
            e.setStatic(_static);
        }
        if (_types) {
            e.setTypes(_types);
        }
        if (returnType) {
            e.setReturnType(returnType);
        }
        accessor = "";
    }
    function processField() {
        e = new Field(name);
        dStop = endStatement(str, dStop, statementEnders);
        i = dStop.index;
        if ((_cmt = _processComments(str, i, n))) {
            i = _cmt.index;
            //TODO
        }
        e.setStatic(_static);
        e.setPrivate(_private);
        if (type) {
            e.setType(type);
        }
    }
    
    while (i < n) {
        if (!_cmt && (_cmt = _processComments(str, i, n))) {
            i = _cmt.index;
            startLineNum = _cmt.startLineNum;
            _cmt = _cmt.object;
            if (e) {
                if (lastLineNum === startLineNum) {
                    if (_cmt instanceof Comment) {
                        e.setInlineComment(_cmt);
                        _cmt = null;
                    } else if (_cmt instanceof Comments) {
                        e.setInlineComment(_cmt.remove(0));
                    }
                }
            }
        }
        if (str[i] === '}') {
            var c = new Class(cname, ext, { 
                elements: elts, 
                topInlineComment: icmt,
                endComment : _cmt
            } );
            if (_types) {
                c.setTypes(_types);
            }
            if (ext) {
                c.setExtends(ext);
            }
            if (impl) {
                c.setImplements(impl);
            }
            if (cmt) {
                c.setComment(cmt);
            }
            lastLineNum = lineNum;
            lastIndex = i + 1;
            //skip character '}' and spaces
            i = skipSpaces(str, i + 1, n);
            return endComment(str, i, n, c, lastLineNum, lastIndex);                                   
        }
        if (processName())  {                  
            lastLineNum = lineNum;
            i = skipSpaces(str, nameRe.lastIndex, n);
            if (i >= n) {
                unexpectedEnd();
            }
            _cmt = processComments(str, lastLineNum, i, n, qkey, '', true);
            i = _cmt.index;
            _cmt = _cmt.comment;
            accessor = "";
            if (name === 'get' || name === 'set') {
                if (generator) {
                    throw new Error("Unexpected keyword '" + name + "' at line " + lineNum + ', column ' + getColumn(i) +  ' and index ' + i);
                }
                initAccessor();
            } else if (name) {
                key = name;
            }
            if (names.indexOf(key) >= 0) {
                throw new Error("Too many elements with the name '" + name + "'");
            } else {
                names[names.length] = key;
            }
            var typ;
            if (str[i] === ':') {
                typ = processType(str, i, n, ctx, [';', '}', '=', ',']);
                i = ctx.index;
            } else {
                typ = null;
            }
            lastLineNum = lineNum;
            if (str[i] === '=') { //field default value case
                if (_async) {
                    throw new Error("Expected character '(', found '='");
                }
                processValuedField();                       
            } else if (str[i] === '(') { //method parameters open
                processCallable();
                e.setAsync(_async);
                _async = false;
            } else if ((dStop = isStop(str,i,statementEnders, lastLineNum))) {
                if (_async) {
                    throw new Error("Expected character '(', found '" + str[i] + "'");
                }
                processField();
            } else {
                unexpectedChar(str, lineNum, getColumn(i), i);
            }
            elts[elts.length] = e;
        } else {
            //e is a computed name method processed in processName call
            elts[elts.length] = e;
        }
    }
    unexpectedEnd();
}
/**
* 
* @private
* @param {String} str  The tring to parse
* @param {unsigned int} i  The parse offset index
* @param {unsigned int} n  The length of the string or ubstring to parse
* @param {Array} stop
* @param {String} keyword Keyword already parsed
* @param {Boolean} named The function must be abolutely named ? if false, it can be named or not
* @param {IComment} cmt The comment
* @param {Object} [ctx] The comment
* @returns {Object}
*/
function parseFunctionStatement(str, i, n, stop, keyword, named, cmt, ctx) {
    var s, f = parseFunction(str, i, n, stop, keyword, named, cmt, ctx);
    f = chainRef(f.object, str, stop, n, /* start */i, f.lastIndex, f.index, f.lastLineNum, f);
    if ((s = isStop(str, f, stop))) {
        if (statementEnderSkipables[s.ender]) {
            s.lastIndex = s.lastIndex + s.ender.length;
            s.index = skipSpaces(str, s.lastIndex);
        }
    }
    return f;
}
/**
* 
* @private
* @param {String} str  The tring to parse
* @param {unsigned int} i  The parse offset index
* @param {unsigned int} n  The length of the string or ubstring to parse
* @param {Array} stop
* @param {String} keyword Keyword already parsed
* @param {Boolean} named The function must be abolutely named ? if false, it can be named or not
* @param {IComment} cmt The comment
* @param {Object} [ctx] context
* @returns {Object}
*/
function parseFunction(str, i, n, stop, keyword, named, cmt, ctx) {
    var _cmt, cstop, lastLineNum = lineNum;
    if (ctx) {
        cstop = ctx.stop;
    } else {
        ctx = {};
    }
    var func = { generator : false};
    //skip the keyword 'function'
    i += 8;
    if (str[i] === '*') { //check if function generator
        //skip the character '*'
        i++;
        func.generator = true;
    }
    //skip spaces and process comments
    _cmt = processComments(str, lastLineNum, skipSpaces(str, i, n), n, func, 'beforeName', false);
    i = _cmt.index;
    var name,  _types,
        re = regexps["simple-name"], 
        match;
    if (str[i] === '<') {
        _types = processNamedTypes(str, i, n, ctx);
        i = ctx.index;
        //skip spaces and process comments
        _cmt = processComments(str, ctx.lastLineNum, i, n, _types, 'outer', false);
        i = _cmt.index;
        if (str[i] !== '(') {
            throw new Error("Expected character '('");
        }
        name = "";
    } else if (str[i] === '(') {
        if (named) {
            throw new Error("Function name expected. Found character '('");
        }
        name = "";
    } else {
        if (!(match = regexMatch(re, str, i))) {
            unexpectedChar(str[i], lineNum, getColumn(i), i);
        }
        name = match[0];
        var comments = {};
        lastLineNum = lineNum;
        //skip spaces and process comments
        _cmt = processComments(str, lastLineNum, skipSpaces(str, re.lastIndex, n), n, comments, '', false);
        i = _cmt.index;  
        if (str[i] === '<') {
            _types = processNamedTypes(str, i, n, ctx);
            if (comments.comment) {
                _types.setComment(comments.comment);
            }
            if (comments.inlineComment) {
                _types.setInlineComment(comments.inlineComment);
            }
            i = ctx.index;
            //skip spaces and process comments
            _cmt = processComments(str, ctx.lastLineNum, i, n, _types, 'outer', false);
            i = _cmt.index;
        }
        if (str[i] !== '(') {
            unexpectedChar(str[i], lineNum, getColumn(i), i);
        }
    }
    if ((_cmt = _processComments(str, i, n))) {
        //TODO
        i = _cmt.index;
    }
    var params;
    parseParams(str, i, n, ctx);
    i = ctx.index;
    params = ctx.object;

    var returnType;
    if (str[i] === ':') {
        returnType = processType(str, i, n, ctx, ['{']);
        i = ctx.index;        
    }
    if (str[i] !== '{') {
        throw new Error("Expected character '{', found '" + str[i] + "'"
                + " at line " + lineNum + ", column " + (getColumn(i)) + " and index " + i);
    }
    if ((_cmt = _processComments(str, i, n))) {
        //TODO
        i = _cmt.index;

    }
    parseBlock(str, i, n, expressionAsStatement, ctx);
    func.name= name, //the function name
    func.params = params, //the parameters of the function
    func.body = ctx.object instanceof Block ? ctx.object : new Block(ctx.object), //the body of the function
    func.comment = cmt;
    ctx.object = Func.getFunction(func);
    if (_types) {
        ctx.object.setTypes(_types);
    }
    if (returnType) {
        ctx.object.setReturnType(returnType);
    }
    if (cstop) {
        ctx.stop = cstop;
    }
    return ctx;
}
/**
* 
* @private
* @param {String} str  The tring to parse
* @param {unsigned int} i  The parse offset index
* @param {unsigned int} n  The length of the string or ubstring to parse
* @param {Array} stop
* @param {Boolean} named The function must be named ?
* @param {Object} [ctx] context
* @returns {Object}
*/
function parseInterface(str, i, n, stop, ctx) {
    var _cmt, cstop, lastLineNum = lineNum;
    if (ctx) {
        cstop = ctx.stop;
    } else {
        ctx = {};
    }
    var interf = {};
    //skip the keyword 'interface' and process comments
    _cmt = processComments(str, lastLineNum, skipSpaces(str, i + 9, n), n, interf, 'beforeName', false);
    i = _cmt.index;
    var name,  _types, ext,
        re = regexps["simple-name"], 
        match;
    if (!(match = regexMatch(re, str, i))) {
        unexpectedChar(str[i], lineNum, getColumn(i), i);
    }
    name = match[0];
    function parseExtends() {
        lastLineNum = lineNum;
        var comments, interf;        
        ext = [];
        while (i < n) {
            comments = {};
            _cmt = processComments(str, lastLineNum, skipSpaces(str, i, n), n, comments, '', false);
            i = _cmt.index;
            interf = processType(str, i, n, ctx, [',', '{']);
            if (interf instanceof Func || interf instanceof Class || interf instanceof NamedType) {
                throw new Error("Unexpected Function, Class or NamedType object"); 
            }
            if (comments.comment) {
                interf.setComment(comments.comment);
            }
            if (comments.inlineComment) {
                interf.setInlineComment(comments.inlineComment);
            }
            ext[ext.length] = interf;
            i = ctx.index;
            if (str[i] === '{') {
                return ext;
            }
            lastLineNum = lineNum;
            i = i + 1;
        }
        unexpectedEnd();
    }
    
    function parseInterfaceBody() {
        var elements = [], b = { };
        _cmt = processComments(str, lastLineNum, skipSpaces(str, i + 1, n), n, b, 'inner', false);
        i = _cmt.index;
        _cmt = _cmt.comment;
        
        var re = regexps['simple-name'], name, comments, params, returnType,sign, scmt = _cmt;
        
        while (i < n) {
            if ((name = regexMatch(re, str, i))) {
                name = name[0];
                comments = {};
                _cmt = processComments(str, lastLineNum, skipSpaces(str, re.lastIndex, n), n, b, '', false);
                i  = _cmt.index;
                if (str[i] === '(') {
                    parseParams(str, i, n, ctx);
                    params = ctx.object;
                    if (str[ctx.index] === ':') {
                        var c = ctx.comment;
                        ctx.comment = null;
                        returnType = processType(str, ctx.index, n, ctx, statementEnders);                        
                        if (c) {
                            returnType.setComment(c);
                        }
                    }
                    if (isStop(str, ctx, statementEnders)) {
                        sign = returnType ? new Signature(name, params, returnType) : new Signature(name, params);
                        if (scmt) {
                            sign.setComment(scmt);
                            scmt = null;
                        }
                        if (statementEnderSkipables[ctx.ender]) {
                            ctx.lastIndex = ctx.index + ctx.ender.length;
                            ctx.lastLineNum = lineNum;
                            _cmt = processComments(str, lineNum, skipSpaces(str, ctx.lastIndex), str.length, sign, 'outer', false);
                            ctx.index = _cmt.index;
                            scmt = _cmt.comment;
                        }
                        i  = ctx.index;
                        elements[elements.length] = sign;
                    } else {
                        throw new Error("Expected end of statement");
                    }                    
                } else {
                    throw new Error("[[parseInterfaceBody]]: Not yet supported");
                }
            } else if (str[i] === '}') {
                b.elements = elements;
                ctx.lastLineNum = lineNum;
                _cmt = processComments(str, lineNum, skipSpaces(str, i + 1, n), n, b, 'outer', false);
                ctx.index = i = _cmt.index;
                if (_cmt.comment) {
                    ctx.comment = _cmt.comment;
                }
                if (scmt) {
                    b.endComment = scmt;
                }
                return new InterfaceBody(b);
            } else {
                unexpectedChar();
            }
        }
        unexpectedEnd();
    }
    
    
    
    var comments = {};
    lastLineNum = lineNum;
    //skip spaces and process comments
    _cmt = processComments(str, lastLineNum, skipSpaces(str, re.lastIndex, n), n, comments, '', false);
    i = _cmt.index;  
    if (str[i] === '<') {
        _types = processNamedTypes(str, i, n, ctx);
        if (comments.comment) {
            _types.setComment(comments.comment);
        }
        if (comments.inlineComment) {
            _types.setInlineComment(comments.inlineComment);
        }
        i = ctx.index;
        //skip spaces and process comments
        _cmt = processComments(str, ctx.lastLineNum, i, n, _types, 'outer', false);
        i = _cmt.index;
    }
    if ((match = regexMatch(re, str, i))) {
        match = match[0];
        if (match === 'extends') {
            parseExtends();
            if (ext.length === 0) {
                throw new Error("Interface name expected");
            }
        }
    } else {
        if ((_cmt = _processComments(str, i, n))) {
            //TODO
            i = _cmt.index;
        }
        if (str[i] !== '{') {
            throw new Error("Unexpected character '{', found '" + str[i] + "'"
                    + " at line " + lineNum + ", column " + (getColumn(i)) + " and index " + i);
        }
    }
    
    interf.name= name, //the interface name
    interf.extends = ext;
    interf.types = _types;
    interf.body = parseInterfaceBody();
    ctx.object = new Interface(interf);

    if (cstop) {
        ctx.stop = cstop;
    }
    return ctx;
}
/**
* 
* @private
* @param {type} str
* @param {type} i
* @param {type} n
* @param {type} stop
* @param {type} ref
* @param {type} nameRe
* @param {type} callType
* @returns {Object}
*/
function cascade(str, i, n, stop, ref, nameRe, callType, lastIndex, lastLineNum, chainers) {
    var optionalChaining = false, ctx,                 
        match;


    if (isArray(arguments[6])) {
        chainers = arguments[6];
    }

    if (typeof lastIndex === 'undefined' || lastIndex === null) {
        lastIndex = i;
    }

    if (typeof lastLineNum === 'undefined' || lastLineNum === null) {
        lastLineNum = lineNum;
    }

    if (!callType) {
        callType = "invocation";
    }
    if (isPlainObject(chainers)) {
        ctx = chainers;
        chainers = null;
    }
    if (!chainers) {
        chainers = callType === "none" || callType === "no" || callType === "" ? ['.', '['] : ['.', '[', '('];
    }


    if (!nameRe) { nameRe = regexps.name; }
    if (i < n) {
        if (isStop(str, i, stop)) {
            return { object: ref, index: i, lastIndex: lastIndex||i, lastLineNum : lastLineNum};
        }
        var ch, args, _ctx = {}, _closer = [']'], ind, _cmt;
        while (i <n) {
            if ((_cmt = _processComments(str, i, n))) {
                i = _cmt.index;
                if (lastLineNum === _cmt.startLineNum) {
                    if (_cmt.object instanceof Comment) {
                        ref.setInlineComment(_cmt.object);
                        _cmt = null;
                    } else {
                        ref.setInlineComment(_cmt.object.remove(0));
                    }
                } 
                if (_cmt) {
                    ref.setComment(_cmt.object);
                    _cmt = null;
                }                            
            }
            ch = str[i];
            if (ch === '(') {
                if (chainers.indexOf(ch) < 0) {
                    break;
                }
                args = parseArgs(str, i, n);                                
                ref = Expression.getInstance({ type: callType, callable: ref,  "arguments": args.object, optionalChaining: optionalChaining });
                lastIndex = args.lastIndex; 
                lastLineNum = args.lastLineNum;
                i = args.index;
                optionalChaining = false; 
                callType = "invocation";
            } else if (ch === '[') {
                if (chainers.indexOf(ch) < 0) {
                    break;
                }
                _ctx.offset = skipSpaces(str, i + 1, n);
                _ctx.stop = _closer;
                _ctx.object = null;
                ind = parseExpression(str, _ctx);
                ref = optionalChaining ? new OCIndex(ref, ind) : new Index(ref, ind);
                lastIndex = _ctx.index + 1; 
                lastLineNum = lineNum;
                //skip closing character ']' and spaces
                i = skipSpaces(str, lastIndex, n);
                optionalChaining = false;
            } else if ( ch === '.') {
                if (chainers.indexOf(ch) < 0) {
                    break;
                }
                if (optionalChaining) {
                    unexpectedChar(ch, i); //throw exception
                }    
                i = skipSpaces(str, i + 1, n);
                if (i >= n) {
                    unexpectedEnd();
                }
                if (!(match = regexMatch(nameRe, str, i))) {
                    unexpectedChar(ch, i);
                }
                ref = new Reference(match[0], ref);
                lastIndex = nameRe.lastIndex; 
                lastLineNum = lineNum;
                i = skipSpaces(str, lastIndex, n);                            
                optionalChaining = false;
            } else if (str.startsWith("?.", i)) {
                if (chainers.indexOf('.') < 0) {
                    break;
                }
                if (optionalChaining ) {
                    unexpectedChar(ch, i); 
                }
                optionalChaining = true;
                lastIndex = i + 2; 
                lastLineNum = lineNum;
                i = skipSpaces(str, i + 2, n);                                
            } else if (str.startsWith("??", i)) { //null coalescing case
                var ctx = { offset: skipSpaces(str, i + 2, n), stop : stop };
                ctx.object = new NullCoalescing(ref, parseExpression(str, ctx));
                return ctx;
            } else if (optionalChaining && (match = regexMatch(nameRe, str, i))) {
                ref = new OCRef(match[0], ref);
                optionalChaining = false;
                lastLineNum = lineNum;
                lastIndex = nameRe.lastIndex; 
                i = skipSpaces(str, i + match[0].length, n); 
            } else {
                break;
            }
        }
    }
    return { object: ref, index: i, lastIndex: lastIndex, lastLineNum: lastLineNum};
}
/**
* 
* @param {type} str
* @param {type} i
* @returns {Boolean}
*/
function nameStart(str, i) {
return "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_".indexOf(str[i]) >= 0;
}
    /**
     * 
     * @param {type} obj
     * @param {type} str
     * @param {type} stop
     * @param {unsigned int} n
     * @param {unsigned int} start
     * @param {unsigned int} lastIndex
     * @returns {Object}
     * @see chainRef
     */
    function chainAssignable(obj, str, stop, n, start, lastIndex) {
        var result = chainRef.apply(this, [].slice(arguments));
        if (!(result.object instanceof Reference || result.object instanceof Index)) {
            throw new Error("The parsed object not assignable");
        }
        return result;
    }
    /**
     * Parse Destructuring Assignments left list
     * @param {type} str
     * @param {type} i
     * @param {type} n
     * @returns {Object}
     */
    function parseDALeftList(str, i, n) {

        //skip character '['
        i = skipSpaces(str, i + 1, n);

        var elts = [], arg = false, lastIndex, nameRe = regexps['name'], stop = [',', ']'], start;

        while (i <n) {
            if (str[i] === ']') {
                if (arg !== false) {
                    elts[elts.length] = arg ? undefined : arg;
                }
                lastIndex = i + 1;
                i = skipSpaces(str, i + 1, n);                        
                return  { object: elts, index: i };
            } else if (str[i] === ',') {
                if (!arg) {                            
                    arg = undefined;
                }
                elts[elts.length] = arg;
                i = skipSpaces(str, i + 1, n);
                arg = null;
            } else if (nameStart(str, i)){
                start = i;
                arg = regexMatch(nameRe, str, i)[0];
                i = skipSpaces(str, nameRe.lastIndex, n);
                //chainAssignable(obj, str, stop, n, start, lastIndex)
                arg = chainAssignable(new Reference(arg), str, stop, n, start, i);
                i = arg.index;
                arg = arg.object;
            } else if (str.startsWith("...", i)) {
                i += 3;
                if (!nameStart(str, i)){
                    unexpectedChar(str[i], lineNum, getColumn(i), i);
                }
                start = i;
                arg = regexMatch(nameRe, str, i)[0];
                i = skipSpaces(str, nameRe.lastIndex, n);
                //chainAssignable(obj, str, stop, n, start, lastIndex)
                arg = chainAssignable(new Reference(arg), str, stop, n, start, i);
                i = arg.index;
                if (str[i] !== ']') {
                    expectedChar(
                            ']', // the expected character
                            str[i], // the found character
                            lineNum,  // the line number
                            getColumn(i), // the current column
                            i
                    ); //throw expected character ex<ception
                }
            } else {
                unexpectedChar(
                        str[i], // the unexpected character
                        lineNum,  // the line number
                        getColumn(i), // the current column
                        i
                ); //throw expected character ex<ception
            }
        }
        unexpectedEnd();
    }

    function parseDALeftObject(str, i, n) {

    }
    /**
     * 
     * @param {type} str
     * @param {type} i
     * @param {type} n
     * @param {String} [declarationKeyword=""] declaration keyword
     * @returns {undefined}
     */
    function parseDestructuringAssignement(str, i, n, dKeyword) {
        if (!dKeyword) {
            dKeyword = "";
        }
        var ch = str[i], left;
        if (ch === '[') {
            left = parseDALeftList(str, i, n);
        } else if (ch === '{') {
            left = parseDALeftObject(str, i, n);
        }

        var ctx = left, _cmt, lastLineNum = lineNum, startLineNum;
        left = left.object;
        if ((_cmt = _processComments(str, ctx.index, n))) {
            i = _cmt.index;
            startLineNum = _cmt.startLineNum;
            _cmt = _cmt.object;
            if (lastLinNum === startLineNum) {
                if (_cmt instanceof Comment) {
                    left.setInlineEndComment(_cmt);
                    _cmt = null;
                } else {
                    left.setInlineEndComment(_cmt.remove(0));
                }
            }
            //TODO
        }
        if (str[i] !==  '=') {
            throw new Error("Expected assignement operator '='");
        }
        //skip character '=' and spaces
        i = skipSpaces(str, i + 1, n);
        if ((_cmt = _processComments(str, ctx.index, n))) {
            i = _cmt.index;
            _cmt = _cmt.object;
            //TODO
        }
        ctx.offset = i;
        ctx.stop = [';', '}', unclosedStatementEnd, ','];
        var e = parseExpression(str, ctx);
        if (_cmt) {
            e.setComment(_cmt);
        }
        ctx.object = new ADAssign(left, e);
        var dStop = isStop(str, ctx);
        ctx.ender = dStop.ender;
        return endStatement(str, ctx);
    }
    /**
     * 
     * @private
     * @param {type} str
     * @param {type} i
     * @param {type} n
     * @param {ExportStatement} stmt
     * @returns {String}
     */
    function endExportAggregating(str, i, n, stmt) {
        var match, nameRe = regexps['simple-name'];
        if ((match = regexMatch(nameRe, str, i, n))) { 
            i = skipSpaces(str, nameRe.lastIndex, n);
            match = match[0];
            if (match !== 'from') {
                throw new Error("Expected substring 'from', found '" + match + "'");
            }
        } else {
            throw new Error("Expected substring 'from'");
        }

        if (!(match = regexMatch(qstring, str, i))) {
            throw new Error("Expected quoted string, found character '" + str[i] + "'");
        }
        i = skipSpaces(str, qstring.lastIndex, n);
        var qs = QString.getInstance(match[0]);
        var _cmt, ctx;
        if ((_cmt = _processComments(str, i, n))) {
            i = _cmt.index;
            _cmt = _cmt.object;

            //TODO
        }
        if (!(ctx = isStop(str, i, [';', unclosedStatementEnd]))) {
            throw new Error("Expected end of statement");
        }
        var endInlineComment;
        if (ctx.ender === ';') {
            ctx.lastLineNum = lineNum;
            ctx.index = skipSpaces(str, ctx.index + 1, n);
            var _cmt;
            if ((_cmt = _processComments(str, ctx.index, n))) {
                ctx.index = _cmt.index;
                _cmt = _cmt.object;
                if (_cmt instanceof Comment) {
                    endInlineComment = _cmt;
                    _cmt = null;
                } else {
                    endInlineComment = _cmt.remove(0);
                    ctx.comment = _cmt;
                }
            }
        }
        ctx.object = new Export(new Aggregation({ statement: stmt, from : qs }));;
        if (endInlineComment) {
            ctx.object.setInlineEndComment(endInlineComment);
        }
        return ctx; 
    }
    /**
     * 
     * @private
     * @param {String} str
     * @param {Number} i
     * @param {Number} n
     * @returns {Object}
     */
    function parseExportList(str, i, n) {
        //'{'and spaces already skipped
        
        
        var lastLineNum = lineNum;
        var _cmt, nameRe = regexps['simple-name'], name, match, 
                afterNameInlineComment;
        var list = new EList(), ascmt, e;
        if ((_cmt = _processComments(str, i, n))) {
            i = _cmt.index;
            _cmt = _cmt.object;
            if (lastLineNum === _cmt.startLineNum) {
                list.setInnerInlineComment(_cmt);
                _cmt = null;
            } else {
                list.setInnerInlineComment(_cmt.remove(0));
            }                    
        }
        while (i < n) {

            if (!(name = regexMatch(nameRe, str, i))) {
                throw new Error("Name expected");
            }
            name = name[0];
            lastLineNum = lineNum;
            i = skipSpaces(str, nameRe.lastIndex, n);
            if ((_cmt = _processComments(str, i, n))) {
                i = _cmt.index;
                _cmt = _cmt.object;
                if (lastLineNum === lineNum) {
                    if (_cmt instanceof Comment) {
                        afterNameInlineComment = _cmt; 
                        _cmt = null;
                    } else {
                        afterNameInlineComment = _cmt.remove(0);
                        //TODO
                    }
                }
                //TODO
            }
            if (str[i] === ':') {
                var ctx = { 
                    offset :  skipSpaces(str, i + 1, n), 
                    stop: [',', '}', function() {
                       return !!regexMatch(/\bas\b/g, str, i);
                    }]};
                list.add(e = new VEName({ name : name, value: parseExpression(str, ctx)}));
                lastLineNum = lineNum;
                i = ctx.index;
                _cmt = ctx.comment;
            } else if ((match = regexMatch(nameRe, str, i))) {
                if (match[0] !== 'as') {
                    throw new Error("String 'as' expected");
                }
                lastLineNum = lineNum;
                i = skipSpaces(str, nameRe.lastIndex, n);
                if ((ascmt = _processComments(str, i, n))) {
                    i = _cmt.index;
                    ascmt = ascmt.object;
                    if (lastLineNum === lineNum) {

                    }
                    //TODO
                }
                if ((match = regexMatch(nameRe, str, i))) {
                    match = match[0];
                    if (_cmt) {
                        e.setAfterNameComment(_cmt);
                    }
                    if (match === 'default') {
                        //check if default is for the firt element of the list
                        //If list has at least one element throw exception
                        if (list.length > 0) {
                            throw new Error("Too many default keyword");
                        }
                        list.add(e = new DefaultEName(name));
                    } else {
                        list.add(e = new AliasEName(name, match));
                    }
                    if (ascmt) {
                        e.setAsComment(ascmt);
                        ascmt = null;
                    }
                    lastLineNum = lineNum;
                    i = skipSpaces(str, nameRe.lastIndex, n);
                }
            } else {
                list.add(e = new EName(name));
                lastLineNum = lineNum;
            }
            if (afterNameInlineComment) {
                e.setAfterNameInlineComment(afterNameInlineComment);
                afterNameInlineComment = null;
            }
            if (_cmt) {
                e.setComment(_cmt);
            }

            if ((_cmt = _processComments(str, i, n))) {
                i = _cmt.index;
                _cmt = _cmt.object;
                if (lastLineNum === lineNum) {
                    if (_cmt instanceof Comment) {
                        e.setInlineComment(_cmt); 
                        _cmt = null;
                    } else {
                        e.setInlineComment(_cmt.remove(0));
                        //TODO
                    }
                }
                //TODO
            }
            if (str[i] === '}') {
                if (_cmt) {
                    list.setEndComment(_cmt);
                }
                return { object: list, lastLineNum: lineNum, lastIndex: i + 1, index: skipSpaces(str, i + 1, n)};
            }
            if (str[i] === ',') {
                if (_cmt) {
                    e.setEndComment(_cmt);
                }
                lastLineNum = lineNum;
                i = skipSpaces(str, nameRe.lastIndex, n);
                if ((_cmt = _processComments(str, i, n))) {
                    i = _cmt.index;
                    _cmt = _cmt.object;
                    if (lastLineNum === _cmt.startLineNum) {
                        if (_cmt instanceof Comment) {
                            e.setInlineComment(_cmt);
                            _cmt = null;
                        } else {
                            e.setInlineComment(_cmt.remove);
                        }
                    }
                }
            } else {
                throw new Error("Unexpected character");
            }
        }
    }

    /**
     * 
     * @param {String} str
     * @param {Number} i
     * @param {Number} n
     * @returns {Object}
     */
    function parseImportList(str, i, n) {
        var lastLineNum = lineNum;
        //skip '{'and spaces
        i = skipSpaces(str, i + 1, n);
        var _cmt, nameRe = regexps['simple-name'], name, match, 
                afterNameInlineComment;
        var list = new EList(), ascmt, e;
        if ((_cmt = _processComments(str, i, n))) {
            i = _cmt.index;
            _cmt = _cmt.object;
            if (lastLineNum === _cmt.startLineNum) {
                list.setInnerInlineComment(_cmt);
                _cmt = null;
            } else {
                list.setInnerInlineComment(_cmt.remove(0));
            }                    
        }
        while (i < n) {
            if (str.startsWith("...", i)) {
                i = skipSpaces(str, i + 3, n);
                list.add(new RestEName());
                if (str[i] !== '}') {
                    throw new Error("Eexpected character '}'. found: '" + str[i] + "'");
                }
                if (_cmt) {
                    list.setEndComment(_cmt);
                }
                return { object: list, lastIndex: i + 1, lastLineNum: lineNum, index: skipSpaces(str, i + 1, n)};
            }
            if (!(name = regexMatch(nameRe, str, i))) {
                throw new Error("Name expected");
            }
            name = name[0];
            lastLineNum = lineNum;
            i = skipSpaces(str, nameRe.lastIndex, n);
            if ((_cmt = _processComments(str, i, n))) {
                i = _cmt.index;
                _cmt = _cmt.object;
                if (lastLineNum === lineNum) {
                    if (_cmt instanceof Comment) {
                        afterNameInlineComment = _cmt; 
                        _cmt = null;
                    } else {
                        afterNameInlineComment = _cmt.remove(0);
                        //TODO
                    }
                }
                //TODO
            }
            if (str[i] === ':') {
                throw new Error("Unexpected character ':'");
            } else if ((match = regexMatch(nameRe, str, i))) { //check if the name is followed by 'as'
                if (match[0] !== 'as') {
                    throw new Error("String 'as' expected");
                }
                lastLineNum = lineNum;
                i = skipSpaces(str, nameRe.lastIndex, n);
                if ((ascmt = _processComments(str, i, n))) {
                    i = _cmt.index;
                    ascmt = ascmt.object;
                    if (lastLineNum === lineNum) {

                    }
                    //TODO
                }
                if ((match = regexMatch(nameRe, str, i))) {
                    match = match[0];
                    if (_cmt) {
                        e.setAfterNameComment(_cmt);
                    }
                    if (match === 'default') {
                        throw new Error("Unexpected default keyword");
                    } else {
                        list.add(e = new AliasEName(name, match));
                    }
                    if (ascmt) {
                        e.setAsComment(ascmt);
                        ascmt = null;
                    }
                    lastLineNum = lineNum;
                    i = skipSpaces(str, nameRe.lastIndex, n);
                }
            } else {
                list.add(e = new EName(name));
            }
            if (afterNameInlineComment) {
                e.setAfterNameInlineComment(afterNameInlineComment);
                afterNameInlineComment = null;
            }
            if (_cmt) {
                e.setComment(_cmt);
            }

            if ((_cmt = _processComments(str, i, n))) {
                i = _cmt.index;
                _cmt = _cmt.object;
                if (lastLineNum === lineNum) {
                    if (_cmt instanceof Comment) {
                        e.setInlineComment(_cmt); 
                        _cmt = null;
                    } else {
                        e.setInlineComment(_cmt.remove(0));
                        //TODO
                    }
                }
                //TODO
            }
            if (str[i] === '}') {
                if (_cmt) {
                    list.setEndComment(_cmt);
                }
                return { object: list, lastLineNum : lineNum, lastIndex: i + 1, index: skipSpaces(str, i + 1, n)};
            }
            if (str[i] === ',') {
                if (_cmt) {
                    e.setEndComment(_cmt);
                }
                lastLineNum = lineNum;
                i = skipSpaces(str, i + 1, n);
                if ((_cmt = _processComments(str, i, n))) {
                    i = _cmt.index;
                    _cmt = _cmt.object;
                    if (lastLineNum === _cmt.startLineNum) {
                        if (_cmt instanceof Comment) {
                            e.setInlineComment(_cmt);
                            _cmt = null;
                        } else {
                            e.setInlineComment(_cmt.remove);
                        }
                    }
                }
            } else {
                throw new Error("Unexpected character");
            }
        }
    }



    /**
     * 
     * @param {type} str
     * @param {type} i
     * @param {type} n
     * @returns {Import}
     */
    function parseImport(str, i, n, ctx) {
        //skip 'import'keyword and spaces
        var i = skipSpaces(str, i + 6, n);
        var _cmt, imp, stmt;
        if ((_cmt = _processComments(str, i, n))) {
            i = _cmt.index;
            _cmt = _cmt.object;
            //TODO
        }
        var ch = str[i], qstringRe = regexps.qstring, defaultExport;

        if (ch === '"' || ch === "'") { //for quoted string : module name
            var module = regexMatch(qstringRe, str, i);
            if (!module) {
                throw new Error("Unclosed quoted string");
            }
            stmt = new EModule(module.getValue());
            var lastIndex = qstringRe.lastIndex,
                lastLineNum = lineNum;
            i = skipSpaces(str, qstringRe.lastIndex, n);
            return { 
                object : new Import(stmt), 
                index: i, 
                lastIndex: lastIndex, 
                lastLineNum: lastLineNum 
            };
        }               

        if (ch === '(') {
            var callType = "invocation";
            args = parseArgs(str, i, n);                                
            imp = Expression.getInstance({ type: callType, callable: ref,  "arguments": args.object, optionalChaining: optionalChaining });
            var stop = [ ';', '}', unclosedStatementEnd, ','];
            i = args.index;
            var optionalChaining = false; 
            return cascade(str, i, n, stop, imp, regexps.name, callType, args.lastIndex, args.lastLineNum);
        } 

        var wordRe = regexps['simple-name'], word;
        if (ch === '*') {
            var all = new All();
            stmt = new ImportSelection();
            stmt.setSelection(all);
            i = skipSpaces(str, i + 1, n);
        } else if (ch === '{') {
            var list = parseImportList(str,i, n);
            stmt = new ImportSelection();
            stmt.setSelection(list.object);
            i = list.index;
        } else {                    
            if (!(word = regexMatch(wordRe, str, i)) ) {
                throw new Error("Default export name expected");
            }
            defaultExport = word[0];
            i = skipSpaces(str, wordRe.lastIndex, n);
            if ((_cmt = _processComments(str, i, n))) {
                i = _cmt.index;
                _cmt = _cmt.object;
                //TODO
            }
            ch = str[i];
            stmt = new ImportSelection();
            if (ch === ',') {
                var list;
                if ((ch = str[i]) === '*') {
                    list = new All();
                } else if (ch === '{') {
                    list = parseImportList(str,i, n);
                    i = list.index;
                    list = list.object;


                } else {
                    throw new Error("Character '*' or '{' expected");
                }
                stmt.setSelection(new ImportElements(defaultExport, list));
            } else {
                stmt.setSelection(new DefaultExport(defaultExport));
            }                   
        }
        if (!(word = regexMatch(wordRe, str, i)) || word[0] !== 'from' ) {
            throw new Error("Keyword'from' expected");
        }
        var module = regexMatch(qstringRe, str, skipSpaces(str, wordRe.lastIndex, n));
        if (!module) {
            throw new Error("Unclosed quoted string");
        }
        stmt.setModule(QString.getInstance(module[0]));
        lastIndex = qstringRe.lastIndex;
        var lastLineNum = lineNum;
        i = skipSpaces(str, lastIndex, n);
        var result = { 
            object : new Import(stmt), 
            lastIndex : lastIndex, 
            index : i, 
            lastLineNum: lastLineNum,
            stop: [';', unclosedStatementEnd] 
        };
        if (!isStop(str, result)) {
            throw new Error("Unexpected character", str[i]);
        }
        if (result.ender) {
            result.lastIndex = lastIndex + result.ender.length;
            result.index = skipSpaces(str, result.lastIndex, n);
        }
        return result;
    }
    /**
     * 
     * <p>Parses in the given string from the given offset index, export  
     * with the following syntax:</p>
     * <h4>Exporting individual features</h4>
     * <ul>
     * <li><b color="blue">export</b> <b color="blue">let</b> name1, name2, …, nameN; // also <b>var</b>, <b>const</b></li>
     * <li><b color="blue">export</b> <b color="blue">let</b> name1 = …, name2 = …, …, nameN; // also <b>var</b>, <b>const</b></li>
     * <li><b color="blue">export</b> <b color="blue">function</b> functionName(){...}</li>
     * <li><b color="blue">export</b> <b color="blue">class</b> ClassName {...}</li>
     * </ul>
     * 
     * <h4>Export list</h4>
     * <ul>
     * <li><b color="blue">export</b> { name1, name2, …, nameN };</li>
     * </ul>
     * <h4>Renaming exports</h4>
     * <li><b color="blue">export</b> { variable1 <b color="blue">as</b> name1, variable2 <b color="blue">as</b> name2, …, nameN };</li>
     * </ul>
     * 
     * <h4>Exporting destructured assignments with renaming</h4>
     * <ul>
     * <li><b color="blue">export</b> <b color="blue">const</b> { name1, name2: bar } = o;</li>
     * </ul>
     * <h4>Default exports</h4>
     * <ul>
     * <li><b color="blue">export</b> <b color="blue">default</b> expression;</li>
     * <li><b color="blue">export</b> <b color="blue">default</b> <b color="blue">function</b> (…) { … } // also class, function*</li>
     * <li><b color="blue">export</b> <b color="blue">default</b> <b color="blue">function</b> name1(…) { … } // also class, function*</li>
     * <li><b color="blue">export</b> { name1 <b color="blue">as</b> <b color="blue">default</b>, … };</li>
     * </ul>
     * 
     * <h4>Aggregating modules</h4>
     * <ul>             * 
     * <li><b color="blue">export</b> * <b color="blue">from</b> …; // does not set the <b>default</b> <b>export</b></li>
     * <li><b color="blue">export</b> * <b color="blue">as</b> name1 <b color="blue">from</b> …; // Draft ECMAScript® 2O21</li>
     * <li><b color="blue">export</b> { name1, name2, …, nameN } <b color="blue">from</b> …;</li>
     * <li><b color="blue">export</b> { import1 <b color="blue">as</b> name1, import2 <b color="blue">as</b> name2, …, nameN } <b color="blue">from</b> …;</li>
     * <li><b color="blue">export</b> { <b color="blue">default</b> } <b color="blue">from</b> …;</li>
     * <li><b color="blue">export</b> { <b color="blue">default</b> <b color="blue">as</b> name} <b color="blue">from</b> …;</li>
     * </ul>
     * 
     * @param {type} str  The string to parse
     * @param {type} i    The offset index from which start the parsing
     * @param {type} n    The length of the string to parse
     * @returns {Export}  The parsed export
     */
    function parseExport(str, i, n, cmt, ctx) {
        if (str.startsWith("export const isServerRendering = () => {", i)) {
            console.log("export const isServerRendering = () => {");
        }
        //skip 'export' keyword
        i = skipSpaces(str, i + 6, n); 

        var ch = str[i], name = regexps['simple-name'], sub, stmt;

        if (ch === '*') {
            sub = regexMatch(name, str, skipSpaces(str, i + 1, n), n);
            sub = sub[0];
            i = skipSpaces(str, name.lastIndex, n);
            if (sub === 'from') {
                i = skipSpaces(str, name.lastIndex, n);
            } else if (sub === 'as') {
                sub = regexMatch(name, str, skipSpaces(str, i + 1, n), n);
                sub = sub[0];
                if (sub === 'from') {
                    i = skipSpaces(str, name.lastIndex, n);

                } else {
                    throw new Error("Expected string 'from', found '" + str[i] +  "'");
                }
            } else {
                throw new Error("Expected string 'from' or 'as', found '" + str[i] +  "'");
            }
        } else if (ch === '{') {
            i = skipSpaces(str, i + 1, n);
            if ((sub = regexMatch(name, str, i, n))) {                    
                sub = sub[0];                
                if (sub === 'default') {
                    var alias = "";
                    i = skipSpaces(str, name.lastIndex, n); 
                    if (str[i] !== '}') {
                        throw new Error("Expected character ')'");
                    }
                    if ((sub = regexMatch(name, str, i, n)) && sub[0] === 'as') {
                        if (!(sub = regexMatch(name, str, i, n)) ) {
                            throw new Error("Alias expected");
                        }
                        sub = sub[0];
                        if (sub === 'from' || JS_STATEMENT_KEYWORDS.indexOf(sub) >= 0) {
                            throw new Error("Alias expected found '" + sub + "'");
                        }
                        alias = sub;
                    }
                    var def = EDefault(alias);
                    i = skipSpaces(str, i + 1, n);                            
                    return endExportAggregating(str, i, n, def);
                } else {
                    var list = parseExportList(str, i, n);
                    i = list.index;
                    list = list.object;
                    var dStop;
                    if ((dStop = isStop(str, i, [';', unclosedStatementEnd]))) {
                        dStop.object = new Export(list);
                        if (dStop.ender === ';') {
                            dStop.lastIndex = i + 1;
                            dStop.index = skipSpaces(str, i + 1, n);
                        }
                        return dStop;
                    }
                    if (!(sub = regexMatch(name, str, i, n)) ) {
                        throw new Error("String 'from' expected");
                    }
                    sub = sub[0];
                    if (sub !== 'from') {
                        throw new Error("Keyword 'from' expected");
                    }
                    return endExportAggregating(str, i, n, def);
                }                     
            } else {
                
            }
        }  else if (ch === '*') {
            i = skipSpaces(str, i + 1, n);
            var alias = "";
            if (str.startsWith("as", i) || "\t\n\r\v\b\0".indexOf(str[i+2] >= 0 )) {
                if ((alias = regexMatch(name, str, i, n))) {
                    i = skipSpaces(str, name.lastIndex, n); 
                    alias = alias[0];
                }
            }

            return endExportAggregating(str, i, n, new All(alias));
        } else {
            var _default = false, spos = i;
            if (!(sub = regexMatch(name, str, i, n))) {
                throw new Error("Expected 'var', 'let', 'const', 'class', 'function' or 'default' keyword");
            } 
            sub = sub[0];                    
            switch (sub) {
                case 'var':
                case 'let':
                case 'const':
                    stmt = parseDeclaration(str, i = skipSpaces(str, name.lastIndex, n), n, statementEnders, sub);                    
                    break; 
                case 'class':
                    stmt = parseClass(str, i, n);
                    break;
                case 'function':
                    stmt = parseFunction(str, i, n);
                    break;
                case 'default': // Default exports
                    stmt = parseExportDefault(str, i = skipSpaces(str, name.lastIndex, n), n);
                    _default = true;
                    break;
                case 'interface':
                    stmt = parseInterface(str, i, n);
                    break;
                case "type": 
                    stmt = parseType(str, i = skipSpaces(str, name.lastIndex, n), n, statementEnders, ctx);
                    break;
                default:
                    throw new Error("Unexpected word '" + sub + "'");
            }
            stmt.object = new Export(stmt.object, _default);
            return stmt;
        }
    }
    /**
     * @example
     * <ul>
     * <li>export default expression;</li>
     * <li>export default function (…) { … } // also class, function*</li>
     * <li>export default function name1(…) { … } // also class, function*</li>
     * </ul>
     * @param {type} str
     * @param {type} i
     * @param {type} n
     * @returns {undefined}
     */
    function parseExportDefault(str, i,n) {
        var sub, name = regexps['simple-name'], stmt;
        if ((sub = regexMatch(name, str, i, n))) {                    
            sub = sub[0];
            if (sub === 'function') {
                stmt = parseFunction(str, i, n); 
                //check if the function name is empty
                if (!stmt.object.getName()) {
                    throw new Error("Named function expected");
                }
                //TODO
                return stmt;
            } else if (sub === 'class') {
                stmt = parseClass(str, i, n); 
                //check if the class name is empty
                if (!stmt.object.getName()) {
                    throw new Error("Named class expected");
                }
                //TODO
                return stmt;
            }  else if (sub === 'interface') {
                stmt = parseInterface(str, i, n); 
                //check if the class name is empty
                if (!stmt.object.getName()) {
                    throw new Error("Named class expected");
                }
                //TODO
                return stmt;
            }
        }
        var stmt = { offset : i, stop : [';', unclosedStatementEnd] };                    
        var expr = parseExpression(str, stmt);
        stmt.object = expr;
        if (stmt.ender === ';') {
            stmt.lastIndex = i + 1;
            stmt.index = skipSpaces(str, i + 1, n);
        }
        return stmt;
    }
    /**
     * 
     * @private 
     * @param {type} str
     * @param {type} i
     * @param {type} n
     * @param {type} stop
     * @param {type} owner
     * @returns {Object}
     */
    function parseRef(str, i, n, stop, owner) {
        if (arguments.length === 3) {
            if (isArray(arguments[2])) {
                stop = arguments[2];
                n = str.length;
            } else if (typeof arguments[2] === 'object') {
                owner = arguments[2];
                stop = null;
            }
        }
        var callType, ref;
        var _new = false, name = regexps.name, match;
        if (isNew(str, i)) {
            _new = true;
            callType = "instantiation";
            i = skipSpaces(str, i + 3, n);

        } else {
            callType = "invocation";
        }



        if ((match = regexMatch(name, str, i))) {
            ref = new Reference(match[0], owner);
            var lastLineNum = lineNum;
            i = skipSpaces(str, name.lastIndex, n);
            return cascade(str, i, n, stop, ref, name, callType, name.lastIndex, lastLineNum);
        } else if (callType === 'instantiation') {
            var _ctx = { offset: i, stop: ['(', ';', '}', unclosedStatementEnd] };
            var _callee = parseExpression(str, _ctx);
            var lastLineNum = lineNum;
            i = _ctx.index;
            return cascade(str, i, n, stop, _callee, name, callType, _ctx.lastIndex, lastLineNum);
        } else {
            return owner;
        }
    }
    /**
     * 
     * @param {type} str
     * @param {type} i
     * @param {type} n
     * @param {Object} [result]
     * @returns {Object}
     */
    function arrowFuncOrGrouping(str, i,  n, result) {
        var ch, ctx =  { stop: [',', ')'] }, lastIndex = i, 
                lastLineNum = lineNum, returnType, comments, option;;
        function getPDef(rest) {
            if (!name) {
                unexpectedChar(str[i], lineNum, getColumn(i), i);
            }
            var type;
            if (str[i] ===':') {              
                typ = processType(str, i, n, ctx, [',', ')', '=']);
                i = ctx.index;
                p = new (rest ? v : Param )(name);
                p.setType(type);
                name = null;
                if (str[i] === '=') {
                    i = skipSpaces(str, i + 1, n);
                    ctx.offset = i;
                    lastLineNum = lineNum;
                    ctx.stop = [',', ')'];
                    p.setDefaultValue(parseExpression(str, ctx));
                    if (bcmt) {
                        p.setComment(bcmt);
                    }
                    i = ctx.index;
                    
                }
            } else {
                i = skipSpaces(str, i + 1, n);
                ctx.offset = i;
                lastLineNum = lineNum;
                p = new (rest ? v : Param )(name, parseExpression(str, ctx));
                if (bcmt) {
                    p.setComment(bcmt);
                }
                i = ctx.index;
                name = null;
            }
            if (option) {
                p.setOptional(option);
                option = false;
            }
            
            if (comments) {
                //TODO: process comments
                comments = null;
            }
            
            inline = lastLineNum === lineNum;
            if ((acmt = _processComments(str, i,  n))) {
                if (inline) {
                    p.setInlineComment(acmt);
                } else {
                    p.setEndComment(acmt);
                }               
                i = acmt.index;
            }
            return p;
        }
        
        var name, params = [], nameRe = regexps['simple-name'], 
                inline, lastLineNum, cmt, p, bcmt, acmt;
        if (str[i] === '(') {
            lastLineNum = lineNum;
            i = skipSpaces(str, i + 1, n);
            inline = lastLineNum === lineNum;
        } else if ((name = regexMatch(nameRe, str, i,n))) {
            name = name[0];
            lastLineNum = lineNum;
            i = skipSpaces(str, nameRe.lastIndex, n);
            inline = lastLineNum === lineNum;
            if ((acmt = _processComments(str, i,  n))) {
                //TODO
                i = acmt.index;
            }
            if (str.startsWith("==", i)) {
                return null;
            }
            if (str[i] === '=' || str[i] === ':') {
                params[params.length] = getPDef();
            } else {
                params[params.length] = new Param(name);
            }
            if (str.startsWith("=>", i)) {
                result.object = params;
                result.arrow = true;
                lastLineNum = lineNum;
                i = skipSpaces(str, i + 2, n);
                result.index = i;
                if ((cmt = _processComments(str, i,  n))) {
                    //TODO
                    result.inlineComment = lastLineNum === lineNum;
                    result.index = cmt.index;
                    result.lastLineNum = lastLineNum;
                }
                result.comment  = cmt;
                return result;
            }  else {
                return null;
            }
        } else {
            return null;
        }
        
        while (i < n) {
            if ((bcmt = _processComments(str, i,  n))) {
                //TODO                
                i = bcmt.index;
            }
            
            if ((name = regexMatch(nameRe, str, i,n))) {
                option = false;
                name = name[0];
                lastLineNum = lineNum;
                i = skipSpaces(str, nameRe.lastIndex, n);
                inline = lastLineNum === lineNum;
                if ((acmt = _processComments(str, i,  n))) {
                    //TODO
                    i = acmt.index;
                }
                if (UnaryOperation.UNARY_OPERATORS.indexOf(name) >= 0) {
                    return null;
                }
                if (str[i] === '?') {
                    option = true;
                    lastLineNum = lineNum;
                    comments = {};
                    var _cmt = processComments(str, lastLineNum, skipSpaces(str, i + 1, n), n, comments, 'afterOption', false);
                    if (str[i = _cmt.index] !== ':') {
                        return null;
                    }
                }
            } else if (str.startsWith("...", i)) {
                if (!(name = regexMatch(nameRe, str, i + 3,n))) {
                    //throw "Unexpected character exception
                    unexpectedChar('.', lineNum, getColumn(i), i);
                }
                name = name[0];
                i = skipSpaces(str, nameRe.lastIndex, n);
                if ((acmt = _processComments(str, i,  n))) {
                    //TODO
                    i = acmt.index;
                }
                if (str[i] === '=') {
                    params[params.length] = getPDef(true);
                } else {
                    params[params.length] = p = new RestParam(name);
                    if (bcmt) {
                        p.setComment(bcmt);
                    }
                    if (acmt) {
                        if (inline) {
                            p.setInlineComment(acmt);
                        } else {
                            p.setEndComment(acmt);
                        }
                    }
                }
                if (i < n && str[i] !== ')') {
                    //throw "Expected character exception
                    expectedChar(')', str[i], lineNum, getColumn(i), i);
                } else {
                    lastLineNum = lineNum;
                    i = skipSpaces(str, i + 1, n);
                    if ((cmt = _processComments(str, i,  n))) {
                        //TODO
                        i = cmt.index;
                    }
                    break;
                }
            }
            
            if (i >= n) {
                return null;
            }
            
            if ((ch = str[i]) === ')' || ch === ',') {
                if (name) {
                    params[params.length] = p = new Param(name);
                    if (bcmt) {
                        p.setComment(bcmt);
                    }
                    if (acmt) {
                        if (inline) {
                            p.setInlineComment(acmt);
                        } else {
                            p.setEndComment(acmt);
                        }
                    }
                    name = null;
                }
                lastLineNum = lineNum;
                lastIndex = i + 1;
                i = skipSpaces(str, i + 1, n);                
                if ((cmt = _processComments(str, i,  n))) {
                    //TODO
                    i = cmt.index;
                }
                if (i >= n) {
                    return null;
                }
                if (ch === ')') {
                    if (str[i] ===':') {
                        try {
                            returnType = processType(str, i, n, ctx, ['=']);
                            i = ctx.index;
                        } catch (ex) {
                            return null;
                        }
                    }
                    break;
                }
            }  else if ((str[i] === '=' && !str.startsWith("==", i)) || str[i] === ':') {
                params[params.length] = getPDef();
            } else {
                return null;
            }
        } // end while (i <n)        
        if (str.startsWith("=>", i)) {
            if (!result) {
                result = {};
            }
            result.object = { params : params, returnType: returnType };
            result.arrow = true;
            result.lastLineNum = lineNum;
            result.lastIndex = i + 2;
            i = skipSpaces(str, i + 2, n);
            result.index = i;
            if ((cmt = _processComments(str, i,  n))) {
                //TODO
                result.inlineComment = lastLineNum === lineNum;
                result.index = cmt.index;
                result.lastLineNum = cmt.lastLineNum;
                result.lastIndex = cmt.lastIndex;
            }
            result.comment  = cmt;
        } else {
            if (params.length === 1) {
                p = params[0];
                var o = new Reference(p.getName()), v = p.getDefaultValue();
                if (v) {
                    o = new Assign(o, v);
                }
                if (!result) {
                    result = {};
                }
                result.object = new Grouping(o);
                result.arrow = false;
                result.index = i;
                result.lastLineNum = lineNum;
                result.lastIndex = lastIndex;
                if ((cmt = _processComments(str, i,  n))) {
                    //TODO
                    result.index = cmt.index;
                    result.lastLineNum = cmt.lastLineNum;
                    result.lastIndex = cmt.lastIndex;
                    result.inlineComment = lastLineNum === lineNum;
                }
                result.comment  = cmt;
                return result;
            }
            return null;
        }
        return result;
    }
    /**
     * 
     * @param {type} str
     * @param {type} i
     * @param {type} stop
     * @returns {Expression}
     */        
    function parse(str, i, stop) { 
        if (!i || i < 0) {
            i = 0;
        }
        var ctx = isPlainObject(i) ? i : { offset: i||0, stop: stop };
        return parseExpression(str, ctx);
    }
    
    EParser.parse = parse;
    
    EParser.parseExpression = parseExpression;
    
    /**
     * 
     * @param {String} str
     * @returns {Array&lt;Statement|Expression&gt;}
     */
    function parseStatements(str) {
        var offset = 0, stop, _init = false, n;
        var _newLine;
        
        if (arguments.length === 2 ) {
            var o = arguments[1];
            if (isPlainObject(arguments[1])) {
                if (o.newLine) {
                    _newLine = o.newLine;
                }
                offset = parseInt(o.offset);
                if (Number.isNaN(offset) || offset < 0) {
                    offset = parseInt(o.offset);
                    if (Number.isNaN(offset) || offset < 0) {
                        offset = 0;
                    }
                }
                stop = o.stop;
            } else if (isArray(o)) {
                stop = o;
            }
        }
        
        if (_newLine) {
            if (typeof _newLine === 'string') {
                _newLine = [newLine];
            }            
        } else {
            _newLine = newLine;
        }
        
        if (typeof n !== 'number' || n < 0) {
            n = str.length;
        }
        
        if (_newLine) {
            initLine(str, offset, n, _newLine);
        }
        var stmt, 
                i = skipSpaces(str, offset, n),
                _cmt;
        var statements = [];

        while (i < n) {
            if (!_cmt && (_cmt = _processComments(str, i, n))) {
                i = skipSpaces(str, _cmt.index, n);  
                if (stmt && stmt.lineNum === _cmt.startLineNum) {
                    if (_cmt.object instanceof Comment) {
                        stmt.setInlineComment(_cmt.object);
                        _cmt = null;
                    } else {
                        stmt.setInlineComment(_cmt.object.remove(0));
                    }
                }
            } else {
                stmt = parseStatement(str, i, n, stop, _cmt ? _cmt.object : null);
                statements[statements.length] = stmt.object;
                i = skipSpaces(str, stmt.index, n);
                _cmt = stmt.comment;
            }
        }
        if (_cmt) {
            statements[statements.length] = new EmptyStatement({comment: _cmt});            
        }
        return statements;
    }
    
    SParser.parseStatement = parseStatement;
    
    SParser.parse = parseStatements;
})(ExpressionParser, StatementParser, window.grammar);


/**
 * 
 * @class
 */
var SParser = StatementParser;
/**
 * 
 * @class
 */
var EParser = ExpressionParser;